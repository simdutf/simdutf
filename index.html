<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdutf: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdutf
   &#160;<span id="projectnumber">3.2.15</span>
   </div>
   <div id="projectbrief">Unicode at GB/s.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">simdutf Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <a href="https://github.com/lemire/simdutf/actions/workflows/alpine.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/alpine.yml/badge.svg" alt="Alpine Linux" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/lemire/simdutf/actions/workflows/msys2.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/msys2.yml/badge.svg" alt="MSYS2-CI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/lemire/simdutf/actions/workflows/msys2-clang.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/msys2-clang.yml/badge.svg" alt="MSYS2-CLANG-CI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/lemire/simdutf/actions/workflows/ubuntu20sani.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/ubuntu20sani.yml/badge.svg" alt="Ubuntu 20.04 CI (GCC 9)" style="pointer-events: none;" class="inline"/></a> <a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&amp;can=1&amp;q=proj:simdutf"><img src="https://oss-fuzz-build-logs.storage.googleapis.com/badges/simdutf.svg" alt="Fuzzing Status" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Table of contents</h1>
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#simdutf-unicode-validation-and-transcoding-at-billions-of-characters-per-second">simdutf: Unicode validation and transcoding at billions of characters per second</a><ul>
<li><a href="#real-world-usage">Real-World Usage</a></li>
<li><a href="#how-fast-is-it">How fast is it?</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#usage-usage">Usage (Usage)</a></li>
<li><a href="#usage-cmake">Usage (CMake)</a></li>
<li><a href="#single-header-version">Single-header version</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#api">API</a></li>
<li><a href="#the-sutf-command-line-tool">The sutf command-line tool</a></li>
<li><a href="#manual-implementation-selection">Manual implementation selection</a></li>
<li><a href="#references">References</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
simdutf: Unicode validation and transcoding at billions of characters per second</h1>
<p>Most modern software relies on the <a href="https://en.wikipedia.org/wiki/Unicode">Unicode standard</a>. In memory, Unicode strings are represented using either UTF-8 or UTF-16. The UTF-8 format is the de facto standard on the web (JSON, HTML, etc.) and it has been adopted as the default in many popular programming languages (Go, Rust, Swift, etc.). The UTF-16 format is standard in Java, C# and in many Windows technologies.</p>
<p>Not all sequences of bytes are valid Unicode strings. It is unsafe to use Unicode strings in UTF-8 and UTF-16LE without first validating them. Furthermore, we often need to convert strings from one encoding to another, by a process called <a href="https://en.wikipedia.org/wiki/Transcoding">transcoding</a>. For security purposes, such transcoding should be validating: it should refuse to transcode incorrect strings.</p>
<p>This library provide fast Unicode functions such as</p>
<ul>
<li>ASCII, UTF-8, UTF-16LE/BE and UTF-32 validation, with and without error identification,</li>
<li>Latin1 to UTF-8 transcoding,</li>
<li>Latin1 to UTF-16LE/BE transcoding</li>
<li>Latin1 to UTF-32 transcoding</li>
<li>UTF-8 to Latin1 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-8 to UTF-16LE/BE transcoding, with or without validation, with and without error identification,</li>
<li>UTF-8 to UTF-32 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to Latin1 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to UTF-8 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32 to Latin1 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32 to UTF-8 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32 to UTF-16LE/BE transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to UTF-32 transcoding, with or without validation, with and without error identification,</li>
<li>From an UTF-8 string, compute the size of the Latin1 equivalent string,</li>
<li>From an UTF-8 string, compute the size of the UTF-16 equivalent string,</li>
<li>From an UTF-8 string, compute the size of the UTF-32 equivalent string (equivalent to UTF-8 character counting),</li>
<li>From an UTF-16LE/BE string, compute the size of the Latin1 equivalent string,</li>
<li>From an UTF-16LE/BE string, compute the size of the UTF-8 equivalent string,</li>
<li>From an UTF-32 string, compute the size of the UTF-8 or UTF-16LE equivalent string,</li>
<li>From an UTF-16LE/BE string, compute the size of the UTF-32 equivalent string (equivalent to UTF-16 character counting),</li>
<li>UTF-8 and UTF-16LE/BE character counting.</li>
<li>UTF-16 endianness change (UTF16-LE/BE to UTF-16-BE/LE)</li>
</ul>
<p>The functions are accelerated using SIMD instructions (e.g., ARM NEON, SSE, AVX, AVX-512, etc.). When your strings contain hundreds of characters, we can often transcode them at speeds exceeding a billion characters per second. You should expect high speeds not only with English strings (ASCII) but also Chinese, Japanese, Arabic, and so forth. We handle the full character range (including, for example, emojis).</p>
<p>The library compiles down to a small library of a few hundred kilobytes. Our functions are exception-free and non allocating. We have extensive tests and extensive benchmarks.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Real-World Usage</h2>
<p>The simdutf library is used by:</p><ul>
<li><a href="https://nodejs.org/en/">Node.js</a> (19.4.0 or better, 20.0 or better, 18.15 or better), a standard JavaScript runtime environment,</li>
<li><a href="https://bun.sh">Bun</a>, a fast JavaScript runtime environment,</li>
<li><a href="https://github.com/oracle/graaljs">graaljs</a>, a JavaScript implementation by Oracle,</li>
<li><a href="https://www.couchbase.com">Couchbase</a>,</li>
<li><a href="https://github.com/haskell/text">haskell/text</a>, a library for fast operations over Unicode text,</li>
<li><a href="https://github.com/variar/klogg">klogg</a>, a Really fast log explorer,</li>
<li><a href="https://github.com/pixie-io/pixie">Pixie</a>, observability tool for Kubernetes applications.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
How fast is it?</h2>
<p>The adoption of the simdutf library by the popular Node.js JavaScript runtime lead to a significant performance gain:</p>
<blockquote class="doxtable">
<p>Decoding and Encoding becomes considerably faster than in Node.js 18. With the addition of simdutf for UTF-8 parsing the observed benchmark, results improved by 364% (an extremely impressive leap) when decoding in comparison to Node.js 16. (<a href="https://blog.rafaelgss.dev/state-of-nodejs-performance-2023">State of Node.js Performance 2023</a>) </p>
</blockquote>
<p><img src="doc/node2023.png" alt="" width="70%" class="inline"/></p>
<p>Over a wide range of realistic data sources, the simdutf library transcodes a billion characters per second or more. Our approach can be 3 to 10 times faster than the popular ICU library on difficult (non-ASCII) strings. We can be 20x faster than ICU when processing easy strings (ASCII). Our good results apply to both recent x64 and ARM processors.</p>
<p>To illustrate, we present a benchmark result with values are in billions of characters processed by second. Consider the following figures.</p>
<p><img src="doc/utf8utf16.png" alt="" width="70%" class="inline"/></p>
<p><img src="doc/utf16utf8.png" alt="" width="70%" class="inline"/></p>
<p>If your system supports AVX-512, the simdutf library can provide very high performance. We get the following speed results on an Ice Lake Intel processor (both AVX2 and AVX-512) are simdutf kernels:</p>
<p><img src="doc/avx512.png" alt="" width="70%" class="inline"/></p>
<p>Datasets: <a href="https://github.com/lemire/unicode_lipsum">https://github.com/lemire/unicode_lipsum</a></p>
<p>Please refer to our benchmarking tool for a proper interpretation of the numbers. Our results are reproducible.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Requirements</h2>
<ul>
<li>C++11 compatible compiler. We support LLVM clang, GCC, Visual Studio. (Our optional benchmark tool requires C++17.)</li>
<li>For high speed, you should have a recent 64-bit system (e.g., ARM or x64).</li>
<li>If you rely on CMake, you should use a recent CMake (at least 3.15) ; otherwise you may use the <a href="#single-header-version">single header version</a>. The library is also available from Microsoft's vcpkg.</li>
<li>AVX-512 support require a processor with AVX512-VBMI2 (Ice Lake or better) and a recent compiler (GCC 8 or better, Visual Studio 2019 or better, LLVM clang 6 or better). You need a correspondingly recent assembler such as gas (2.30+) or nasm (2.14+): recent compilers usually come with recent assemblers. If you mix a recent compiler with an incompatible/old assembler (e.g., when using a recent compiler with an old Linux distribution), you may get errors at build time because the compiler produces instructions that the assembler does not recognize: you should update your assembler to match your compiler (e.g., upgrade binutils to version 2.30 or better under Linux) or use an older compiler matching the capabilities of your assembler.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Usage (Usage)</h2>
<p>We made a video to help you get started with the library.</p>
<p><a href="https://www.youtube.com/watch?v=H9NZtb7ykYs"><img src="http://img.youtube.com/vi/H9NZtb7ykYs/0.jpg" alt="the simdutf library" class="inline"/></a><br  />
</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Usage (CMake)</h2>
<div class="fragment"><div class="line">cmake -B build</div>
<div class="line">cmake --build build</div>
<div class="line">cd build</div>
<div class="line">ctest .</div>
</div><!-- fragment --><p>Visual Studio users must specify whether they want to build the Release or Debug version.</p>
<p>To run benchmarks, execute the <code>benchmark</code> command. You can get help on its usage by first building it and then calling it with the <code>--help</code> flag. E.g., under Linux you may do the following:</p>
<div class="fragment"><div class="line">cmake -B build</div>
<div class="line">cmake --build build</div>
<div class="line">./build/benchmarks/benchmark --help</div>
</div><!-- fragment --><p>Instructions are similar for Visual Studio users.</p>
<p>To use the library as a CMake dependency in your project, please see <code>tests/installation_tests/from_fetch</code> for an example.</p>
<p>Since ICU is so common and popular, we assume that you may have it already on your system. When it is not found, it is simply omitted from the benchmarks. Thus, to benchmark against ICU, make sure you have ICU installed on your machine and that cmake can find it. For macOS, you may install it with brew using <code>brew install icu4c</code>. If you have ICU on your system but cmake cannot find it, you may need to provide cmake with a path to ICU, such as <code>ICU_ROOT=/usr/local/opt/icu4c cmake -B build</code>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Single-header version</h2>
<p>You can create a single-header version of the library where all of the code is put into two files (<code><a class="el" href="simdutf_8h_source.html">simdutf.h</a></code> and <code>simdutf.cpp</code>). We publish a zip archive containing these files, e.g., see <a href="https://github.com/simdutf/simdutf/releases/download/v3.2.15/singleheader.zip">https://github.com/simdutf/simdutf/releases/download/v3.2.15/singleheader.zip</a></p>
<p>You may generate it on your own using a Python script.</p>
<div class="fragment"><div class="line">python3 ./singleheader/amalgamate.py</div>
</div><!-- fragment --><p>We require Python 3 or better.</p>
<p>Under Linux and macOS, you may test it as follows:</p>
<div class="fragment"><div class="line">cd singleheader</div>
<div class="line">c++ -o amalgamation_demo amalgamation_demo.cpp -std=c++17</div>
<div class="line">./amalgamation_demo</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Example</h2>
<p>Using the single-header version, you could compile the following program.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;memory&gt;</div>
<div class="line"> </div>
<div class="line">#include &quot;simdutf.cpp&quot;</div>
<div class="line">#include &quot;simdutf.h&quot;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char *argv[]) {</div>
<div class="line">  const char *source = &quot;1234&quot;;</div>
<div class="line">  // 4 == strlen(source)</div>
<div class="line">  bool validutf8 = simdutf::validate_utf8(source, 4);</div>
<div class="line">  if (validutf8) {</div>
<div class="line">    std::cout &lt;&lt; &quot;valid UTF-8&quot; &lt;&lt; std::endl;</div>
<div class="line">  } else {</div>
<div class="line">    std::cerr &lt;&lt; &quot;invalid UTF-8&quot; &lt;&lt; std::endl;</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  // We need a buffer of size where to write the UTF-16LE words.</div>
<div class="line">  size_t expected_utf16words = simdutf::utf16_length_from_utf8(source, 4);</div>
<div class="line">  std::unique_ptr&lt;char16_t[]&gt; utf16_output{new char16_t[expected_utf16words]};</div>
<div class="line">  // convert to UTF-16LE</div>
<div class="line">  size_t utf16words =</div>
<div class="line">      simdutf::convert_utf8_to_utf16le(source, 4, utf16_output.get());</div>
<div class="line">  std::cout &lt;&lt; &quot;wrote &quot; &lt;&lt; utf16words &lt;&lt; &quot; UTF-16LE words.&quot; &lt;&lt; std::endl;</div>
<div class="line">  // It wrote utf16words * sizeof(char16_t) bytes.</div>
<div class="line">  bool validutf16 = simdutf::validate_utf16le(utf16_output.get(), utf16words);</div>
<div class="line">  if (validutf16) {</div>
<div class="line">    std::cout &lt;&lt; &quot;valid UTF-16LE&quot; &lt;&lt; std::endl;</div>
<div class="line">  } else {</div>
<div class="line">    std::cerr &lt;&lt; &quot;invalid UTF-16LE&quot; &lt;&lt; std::endl;</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  // convert it back:</div>
<div class="line">  // We need a buffer of size where to write the UTF-8 words.</div>
<div class="line">  size_t expected_utf8words =</div>
<div class="line">      simdutf::utf8_length_from_utf16le(utf16_output.get(), utf16words);</div>
<div class="line">  std::unique_ptr&lt;char[]&gt; utf8_output{new char[expected_utf8words]};</div>
<div class="line">  // convert to UTF-8</div>
<div class="line">  size_t utf8words = simdutf::convert_utf16le_to_utf8(</div>
<div class="line">      utf16_output.get(), utf16words, utf8_output.get());</div>
<div class="line">  std::cout &lt;&lt; &quot;wrote &quot; &lt;&lt; utf8words &lt;&lt; &quot; UTF-8 words.&quot; &lt;&lt; std::endl;</div>
<div class="line">  std::string final_string(utf8_output.get(), utf8words);</div>
<div class="line">  std::cout &lt;&lt; final_string &lt;&lt; std::endl;</div>
<div class="line">  if (final_string != source) {</div>
<div class="line">    std::cerr &lt;&lt; &quot;bad conversion&quot; &lt;&lt; std::endl;</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  } else {</div>
<div class="line">    std::cerr &lt;&lt; &quot;perfect round trip&quot; &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
API</h2>
<p>Our API is made of a few non-allocating function. They typically take a pointer and a length as a parameter, and they sometimes take a pointer to an output buffer. Users are responsible for memory allocation.</p>
<p>We use three types of data pointer types:</p><ul>
<li><code>char*</code> for UTF-8 or indeterminate Unicode formats,</li>
<li><code>char16_t*</code> for UTF-16 (both UTF-16LE and UTF-16BE),</li>
<li><code>char32_t*</code> for UTF-32. UTF-32 is primarily used for internal use, not data interchange. Thus, unless otherwise stated, <code>char32_t</code> refers to the native type and is typically UTF-32LE since virtually all systems are little-endian today.</li>
</ul>
<p>Our functions and declarations are all in the <code>simdutf</code> namespace. Thus you should prefix our functions and types with <code>simdutf::</code> as required.</p>
<p>We have basic functions to detect the type of an input. They return an integer defined by the following <code>enum</code>.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">enum encoding_type {</div>
<div class="line">        UTF8 = 1,       // BOM 0xef 0xbb 0xbf</div>
<div class="line">        UTF16_LE = 2,   // BOM 0xff 0xfe</div>
<div class="line">        UTF16_BE = 4,   // BOM 0xfe 0xff</div>
<div class="line">        UTF32_LE = 8,   // BOM 0xff 0xfe 0x00 0x00</div>
<div class="line">        UTF32_BE = 16,   // BOM 0x00 0x00 0xfe 0xff</div>
<div class="line"> </div>
<div class="line">        unspecified = 0</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"> {C++}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Autodetect the encoding of the input, a single encoding is recommended.</div>
<div class="line"> * E.g., the function might return simdutf::encoding_type::UTF8,</div>
<div class="line"> * simdutf::encoding_type::UTF16_LE, simdutf::encoding_type::UTF16_BE, or</div>
<div class="line"> * simdutf::encoding_type::UTF32_LE.</div>
<div class="line"> *</div>
<div class="line"> * @param input the string to analyze.</div>
<div class="line"> * @param length the length of the string in bytes.</div>
<div class="line"> * @return the detected encoding type</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused simdutf::encoding_type autodetect_encoding(const char * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Autodetect the possible encodings of the input in one pass.</div>
<div class="line"> * E.g., if the input might be UTF-16LE or UTF-8, this function returns</div>
<div class="line"> * the value (simdutf::encoding_type::UTF8 | simdutf::encoding_type::UTF16_LE).</div>
<div class="line"> *</div>
<div class="line"> * Overriden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * @param input the string to analyze.</div>
<div class="line"> * @param length the length of the string in bytes.</div>
<div class="line"> * @return the detected encoding type</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused int detect_encodings(const char * input, size_t length) noexcept;</div>
</div><!-- fragment --><p>For validation and transcoding, we also provide functions that will stop on error and return a result struct which is a pair of two fields: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct result {</div>
<div class="line">  error_code error; // see `struct error_code`.</div>
<div class="line">  size_t count; // In case of error, indicates the position of the error in the input.</div>
<div class="line">  // In case of success, indicates the number of words validated/written.</div>
<div class="line">};</div>
</div><!-- fragment --><p> On error, the <code>error</code> field indicates the type of error encountered and the <code>position</code> field indicates its word position in the input string. We report six types of errors related to Latin1,UTF-8, UTF-16 and UTF-32 encodings: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">enum error_code {</div>
<div class="line">  SUCCESS = 0,</div>
<div class="line">  HEADER_BITS,  // Any byte must have fewer than 5 header bits.</div>
<div class="line">  TOO_SHORT,    // The leading byte must be followed by N-1 continuation bytes, where N is the UTF-8 character length</div>
<div class="line">                // This is also the error when the input is truncated.</div>
<div class="line">  TOO_LONG,     // We either have too many consecutive continuation bytes or the string starts with a continuation byte.</div>
<div class="line">  OVERLONG,     // The decoded character must be above U+7F for two-byte characters, U+7FF for three-byte characters,</div>
<div class="line">                // and U+FFFF for four-byte characters.</div>
<div class="line">  TOO_LARGE,    // The decoded character must be less than or equal to U+10FFFF,less than or equal than U+7F for ASCII OR less than equal than U+FF for Latin1</div>
<div class="line">  SURROGATE,    // The decoded character must be not be in U+D800...DFFF (UTF-8 or UTF-32) OR</div>
<div class="line">                // a high surrogate must be followed by a low surrogate and a low surrogate must be preceded by a high surrogate (UTF-16) OR</div>
<div class="line">                // there must be no surrogate at all (Latin1)</div>
<div class="line">  OTHER         // Not related to validation/transcoding.</div>
<div class="line">};</div>
</div><!-- fragment --><p> On success, the <code>error</code> field is set to <code>SUCCESS</code> and the <code>position</code> field indicates either the number of words validated for validation functions or the number of written words in the output format for transcoding functions.</p>
<p>Generally speaking, functions that report errors always stop soon after an error is encountered and might therefore be faster on inputs where an error occurs early in the input. The functions that return a boolean indicating whether or not an error has been encountered are meant to be used in an <em>optimistic setting</em>&mdash;when we expect that inputs will almost always be correct.</p>
<p>We have fast validation functions.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/**</div>
<div class="line"> * Validate the ASCII string.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the ASCII string to validate.</div>
<div class="line"> * @param len the length of the string in bytes.</div>
<div class="line"> * @return true if and only if the string is valid ASCII.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused bool validate_ascii(const char *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the ASCII string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the ASCII string to validate.</div>
<div class="line"> * @param len the length of the string in bytes.</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result validate_ascii_with_errors(const char *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-8 string. This function may be best when you expect</div>
<div class="line"> * the input to be almost always valid. Otherwise, consider using</div>
<div class="line"> * validate_utf8_with_errors.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-8 string to validate.</div>
<div class="line"> * @param len the length of the string in bytes.</div>
<div class="line"> * @return true if and only if the string is valid UTF-8.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused bool validate_utf8(const char *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-8 string and stop on error. It might be faster than</div>
<div class="line"> * validate_utf8 when an error is expected to occur early.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-8 string to validate.</div>
<div class="line"> * @param len the length of the string in bytes.</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result validate_utf8_with_errors(const char *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Validate the UTF-16 string.</div>
<div class="line"> * This function may be best when you expect the input to be almost always valid.</div>
<div class="line"> * Otherwise, consider using validate_utf16_with_errors.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-16 string to validate.</div>
<div class="line"> * @param len the length of the string in number of 2-byte words (char16_t).</div>
<div class="line"> * @return true if and only if the string is valid UTF-16.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused bool validate_utf16(const char16_t *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-16LE string. This function may be best when you expect</div>
<div class="line"> * the input to be almost always valid. Otherwise, consider using</div>
<div class="line"> * validate_utf16le_with_errors.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-16LE string to validate.</div>
<div class="line"> * @param len the length of the string in number of 2-byte words (char16_t).</div>
<div class="line"> * @return true if and only if the string is valid UTF-16LE.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused bool validate_utf16le(const char16_t *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-16BE string. This function may be best when you expect</div>
<div class="line"> * the input to be almost always valid. Otherwise, consider using</div>
<div class="line"> * validate_utf16be_with_errors.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-16BE string to validate.</div>
<div class="line"> * @param len the length of the string in number of 2-byte words (char16_t).</div>
<div class="line"> * @return true if and only if the string is valid UTF-16BE.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused bool validate_utf16be(const char16_t *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Validate the UTF-16 string and stop on error.</div>
<div class="line"> * It might be faster than validate_utf16 when an error is expected to occur early.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-16 string to validate.</div>
<div class="line"> * @param len the length of the string in number of 2-byte words (char16_t).</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result validate_utf16_with_errors(const char16_t *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-16LE string and stop on error. It might be faster than</div>
<div class="line"> * validate_utf16le when an error is expected to occur early.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-16LE string to validate.</div>
<div class="line"> * @param len the length of the string in number of 2-byte words (char16_t).</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result validate_utf16le_with_errors(const char16_t *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-16BE string and stop on error. It might be faster than</div>
<div class="line"> * validate_utf16be when an error is expected to occur early.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-16BE string to validate.</div>
<div class="line"> * @param len the length of the string in number of 2-byte words (char16_t).</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result validate_utf16be_with_errors(const char16_t *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-32 string.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-32 string to validate.</div>
<div class="line"> * @param len the length of the string in number of 4-byte words (char32_t).</div>
<div class="line"> * @return true if and only if the string is valid UTF-32.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused bool validate_utf32(const char32_t *buf, size_t len) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Validate the UTF-32 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * Overridden by each implementation.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param buf the UTF-32 string to validate.</div>
<div class="line"> * @param len the length of the string in number of 4-byte words (char32_t).</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result validate_utf32_with_errors(const char32_t *buf, size_t len) noexcept;</div>
</div><!-- fragment --><p>Given a valid UTF-8 or UTF-16 input, you may count the number Unicode characters using fast functions. For UTF-32, there is no need for a function given that each character requires a flat 4 bytes. Likewise for Latin1: one byte will always equal one character.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/**</div>
<div class="line"> * Count the number of code points (characters) in the string assuming that</div>
<div class="line"> * it is valid.</div>
<div class="line"> *</div>
<div class="line"> * This function assumes that the input string is valid UTF-16 (native endianness).</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16 string to process</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return number of code points</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t count_utf16(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Count the number of code points (characters) in the string assuming that</div>
<div class="line"> * it is valid.</div>
<div class="line"> *</div>
<div class="line"> * This function assumes that the input string is valid UTF-16LE.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16LE string to process</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return number of code points</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t count_utf16le(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Count the number of code points (characters) in the string assuming that</div>
<div class="line"> * it is valid.</div>
<div class="line"> *</div>
<div class="line"> * This function assumes that the input string is valid UTF-16BE.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16BE string to process</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return number of code points</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t count_utf16be(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Count the number of code points (characters) in the string assuming that</div>
<div class="line"> * it is valid.</div>
<div class="line"> *</div>
<div class="line"> * This function assumes that the input string is valid UTF-8.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to process</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @return number of code points</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t count_utf8(const char * input, size_t length) noexcept;</div>
</div><!-- fragment --><p>Prior to transcoding an input, you need to allocate enough memory to receive the result. We have fast function that scan the input and compute the size of the output. These functions are fast and non-validating.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Return the number of bytes that this Latin1 string would require in UTF-8 format.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the Latin1 string to convert</div>
<div class="line"> * @param length        the length of the string bytes</div>
<div class="line"> * @return the number of bytes required to encode the Latin1 string as UTF-8</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf8_length_from_latin1(const char * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of bytes that this UTF-8 string would require in Latin1 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in byte</div>
<div class="line"> * @return the number of bytes required to encode the UTF-8 string as Latin1</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t latin1_length_from_utf8(const char * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line"> * Compute the number of bytes that this UTF-16LE/BE string would require in Latin1 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-16LE string as Latin1</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t latin1_length_from_utf16(size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of bytes that this UTF-32 string would require in Latin1 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-32 string as Latin1</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t latin1_length_from_utf32(size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of 2-byte words that this UTF-8 string would require in UTF-16 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to process</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @return the number of char16_t words required to encode the UTF-8 string as UTF-16</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf16_length_from_utf8(const char * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of 4-byte words that this UTF-8 string would require in UTF-32 format.</div>
<div class="line"> *</div>
<div class="line"> * This function is equivalent to count_utf8</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to process</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @return the number of char32_t words required to encode the UTF-8 string as UTF-32</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf32_length_from_utf8(const char * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Compute the number of bytes that this UTF-16</div>
<div class="line"> * string would require in UTF-8 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16 string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-16LE string as UTF-8</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf8_length_from_utf16(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16LE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-16LE string as UTF-8</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf8_length_from_utf16le(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16BE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-16BE string as UTF-8</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf8_length_from_utf16be(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of bytes that this UTF-32 string would require in UTF-8 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-32 string as UTF-8</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf8_length_from_utf32(const char32_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of two-byte words that this UTF-32 string would require in UTF-16 format.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-32 string as UTF-16</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf16_length_from_utf32(const char32_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Compute the number of bytes that this UTF-16</div>
<div class="line"> * string would require in UTF-32 format.</div>
<div class="line"> *</div>
<div class="line"> * This function is equivalent to count_utf16.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16 string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-16LE string as UTF-32</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf32_length_from_utf16(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of bytes that this UTF-16LE string would require in UTF-32 format.</div>
<div class="line"> *</div>
<div class="line"> * This function is equivalent to count_utf16le.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16LE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-16LE string as UTF-32</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf32_length_from_utf16le(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Compute the number of bytes that this UTF-16BE string would require in UTF-32 format.</div>
<div class="line"> *</div>
<div class="line"> * This function is equivalent to count_utf16be.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16BE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @return the number of bytes required to encode the UTF-16BE string as UTF-32</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t utf32_length_from_utf16be(const char16_t * input, size_t length) noexcept;</div>
</div><!-- fragment --><p>We have a wide range of conversion between Latin1, UTF-8, UTF-16 and UTF-32. They assume that you are allocated sufficient memory for the input. The simplest conversin function output a single integer representing the size of the input, with a value of zero indicating an error (e.g., <code>convert_utf8_to_utf16le</code>). They are well suited in the scenario where you expect the input to be valid most of the time.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert Latin1 string into UTF8 string.</div>
<div class="line">   *</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the Latin1 string to convert</div>
<div class="line">   * @param length        the length of the string in bytes</div>
<div class="line">   * @param latin1_output  the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return the number of written char; 0 if conversion is not possible</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t convert_latin1_to_utf8(const char * input, size_t length, char* utf8_output) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    /**</div>
<div class="line">   * Convert possibly Latin1 string into UTF-16LE string.</div>
<div class="line">   *</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the Latin1  string to convert</div>
<div class="line">   * @param length        the length of the string in bytes</div>
<div class="line">   * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return the number of written char16_t; 0 if conversion is not possible</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t convert_latin1_to_utf16le(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert Latin1 string into UTF-16BE string.</div>
<div class="line">   *</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the Latin1 string to convert</div>
<div class="line">   * @param length        the length of the string in bytes</div>
<div class="line">   * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return the number of written char16_t; 0 if conversion is not possible</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t convert_latin1_to_utf16be(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert Latin1 string into UTF-32 string.</div>
<div class="line">   *</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the Latin1 string to convert</div>
<div class="line">   * @param length        the length of the string in bytes</div>
<div class="line">   * @param utf32_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return the number of written char32_t; 0 if conversion is not possible</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t convert_latin1_to_utf32(const char * input, size_t length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> /**</div>
<div class="line">   * Convert possibly broken UTF-8 string into latin1 string.</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-8 string to convert</div>
<div class="line">   * @param length        the length of the string in bytes</div>
<div class="line">   * @param latin1_output  the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return the number of written char; 0 if the input was not valid UTF-8 string</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t convert_utf8_to_latin1(const char * input, size_t length, char* latin1_output) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Convert possibly broken UTF-8 string into UTF-16 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return the number of written char16_t; 0 if the input was not valid UTF-8 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf8_to_utf16(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-8 string into UTF-16LE string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return the number of written char16_t; 0 if the input was not valid UTF-8 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf8_to_utf16le(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-8 string into UTF-16BE string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return the number of written char16_t; 0 if the input was not valid UTF-8 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf8_to_utf16be(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-8 string into UTF-32 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf32_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return the number of written char32_t; 0 if the input was not valid UTF-8 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf8_to_utf32(const char * input, size_t length, char32_t* utf32_output) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert possibly broken UTF-16LE string into Latin1 string.</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * This function is not BOM-aware.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-16LE string to convert</div>
<div class="line">   * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line">   * @param latin1_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return number of written words; 0 if input is not a valid UTF-16LE string</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t convert_utf16le_to_latin1(const char16_t * input, size_t length, char* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert possibly broken UTF-16BE string into Latin1 string.</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * This function is not BOM-aware.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-16BE string to convert</div>
<div class="line">   * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line">   * @param latin1_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t convert_utf16be_to_latin1(const char16_t * input, size_t length, char* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16LE string into UTF-8 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16LE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf8_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-16LE string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf16le_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16BE string into UTF-8 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16BE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf8_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-16LE string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf16be_to_utf8(const char16_t * input, size_t length, char* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert possibly broken UTF-32 string into Latin1 string.</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * This function is not BOM-aware.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-32 string to convert</div>
<div class="line">   * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line">   * @param latin1_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return number of written words; 0 if input is not a valid UTF-32 string</div>
<div class="line">   */</div>
<div class="line"> </div>
<div class="line">  simdutf_warn_unused size_t convert_utf32_to_latin1(const char32_t * input, size_t length, char* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-32 string into UTF-8 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf8_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-32 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf32_to_utf8(const char32_t * input, size_t length, char* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Convert possibly broken UTF-32 string into UTF-16 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf16_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-32 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf32_to_utf16(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-32 string into UTF-16LE string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf16_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-32 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf32_to_utf16le(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-32 string into UTF-16BE string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf16_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-32 string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf32_to_utf16be(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Convert possibly broken UTF-16 string into UTF-32 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16 string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf32_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-16LE string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf16_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16LE string into UTF-32 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16LE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf32_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-16LE string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf16le_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16BE string into UTF-32 string.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16BE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf32_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return number of written words; 0 if input is not a valid UTF-16LE string</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t convert_utf16be_to_utf32(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;</div>
</div><!-- fragment --><p>We have more advanced conversion functions which output a <code><a class="el" href="structsimdutf_1_1result.html">simdutf::result</a></code> structure with an indication of the error type and a <code>count</code> entry (e.g., <code>convert_utf8_to_utf16le_with_errors</code>). They are well suited when you expect that there might be errors in the input that require further investigation.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert possibly broken UTF-8 string into latin1 string. with errors</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-8 string to convert</div>
<div class="line">   * @param length        the length of the string in bytes</div>
<div class="line">   * @param latin1_output  the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return a result pair struct with an error code and either the position of the error if any or the number of words validated if successful.</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused result convert_utf8_to_latin1_with_errors(const char * input, size_t length, char* latin1_output) noexcept;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert possibly broken UTF-16LE string into Latin1 string.</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   * This function is not BOM-aware.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-16LE string to convert</div>
<div class="line">   * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line">   * @param latin1_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(const char16_t * input, size_t length, char* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert possibly broken UTF-16BE string into Latin1 string.</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   * This function is not BOM-aware.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-16BE string to convert</div>
<div class="line">   * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line">   * @param latin1_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(const char16_t * input, size_t length, char* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Convert possibly broken UTF-8 string into UTF-16</div>
<div class="line"> * string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf16_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf16_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(const char * input, size_t length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-8 string into UTF-32 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-8 string to convert</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param utf32_buffer  the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf32_with_errors(const char * input, size_t length, char32_t* utf32_output) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16LE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf8_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(const char16_t * input, size_t length, char* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16BE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf8_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(const char16_t * input, size_t length, char* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Convert possibly broken UTF-32 string into Latin1 string and stop on error.</div>
<div class="line">   *</div>
<div class="line">   * During the conversion also validation of the input string is done.</div>
<div class="line">   * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line">   *</div>
<div class="line">   * This function is not BOM-aware.</div>
<div class="line">   *</div>
<div class="line">   * @param input         the UTF-32 string to convert</div>
<div class="line">   * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line">   * @param latin1_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line">   * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</div>
<div class="line">   */</div>
<div class="line"> </div>
<div class="line">  simdutf_warn_unused result convert_utf32_to_latin1_with_errors(const char32_t * input, size_t length, char* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-32 string into UTF-8 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf8_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf8_with_errors(const char32_t * input, size_t length, char* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Convert possibly broken UTF-32 string into UTF-16</div>
<div class="line"> * string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf16_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf16_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf16_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-32 string to convert</div>
<div class="line"> * @param length        the length of the string in 4-byte words (char32_t)</div>
<div class="line"> * @param utf16_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(const char32_t * input, size_t length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Using native endianness; Convert possibly broken UTF-16 string into</div>
<div class="line"> * UTF-32 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16 string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf32_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf16_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16LE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf32_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.</div>
<div class="line"> *</div>
<div class="line"> * During the conversion also validation of the input string is done.</div>
<div class="line"> * This function is suitable to work with inputs from untrusted sources.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16BE string to convert</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param utf32_buffer   the pointer to buffer that can hold conversion result</div>
<div class="line"> * @return a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(const char16_t * input, size_t length, char32_t* utf32_buffer) noexcept;</div>
</div><!-- fragment --><p>If you have a UTF-16 input, you may change its endianess with a fast function.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">/**</div>
<div class="line"> * Change the endianness of the input. Can be used to go from UTF-16LE to UTF-16BE or</div>
<div class="line"> * from UTF-16BE to UTF-16LE.</div>
<div class="line"> *</div>
<div class="line"> * This function does not validate the input.</div>
<div class="line"> *</div>
<div class="line"> * This function is not BOM-aware.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the UTF-16 string to process</div>
<div class="line"> * @param length        the length of the string in 2-byte words (char16_t)</div>
<div class="line"> * @param output        the pointer to buffer that can hold the conversion result</div>
<div class="line"> */</div>
<div class="line">void change_endianness_utf16(const char16_t * input, size_t length, char16_t * output) noexcept;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
The sutf command-line tool</h2>
<p>We also provide a command-line tool which can be build as follows: </p><div class="fragment"><div class="line">cmake -B build &amp;&amp; cmake --build build --target sutf</div>
</div><!-- fragment --><p> This command builds the executable in <code>./build/tool/</code> under most platforms. The sutf tool enables the user to easily transcode files from one encoding to another directly from the command line. The usage is similar to <a href="https://www.gnu.org/software/libiconv/">iconv</a> (see <code>sutf --help</code> for more details). The sutf command-line tool relies on the simdutf library functions for fast transcoding of supported formats (UTF-8, UTF-16LE, UTF-16BE and UTF-32). If iconv is found on the system and simdutf does not support a conversion, the sutf tool falls back on iconv: a message lets the user know if iconv is available during compilation. The following is an example of transcoding two input files to an output file, from UTF-8 to UTF-16LE: </p><div class="fragment"><div class="line">sutf -f UTF-8 -t UTF-16LE -o output_file.txt first_input_file.txt second_input_file.txt</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Manual implementation selection</h2>
<p>When compiling the llibrary for x64 processors, we build several implementations of each functions. At runtime, the best implementation is picked automatically. Advanced users may want to pick a particular implementation, thus bypassing our runtime detection. It is possible and even relatively convenient to do so. The following C++ program checks all the available implementation, and selects one as the default:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">#include &quot;simdutf.h&quot;</div>
<div class="line">#include &lt;cstdlib&gt;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include &lt;string&gt;</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">  // This is just a demonstration, not actual testing required.</div>
<div class="line">  std::string source = &quot;La vie est belle.&quot;;</div>
<div class="line">  std::string chosen_implementation;</div>
<div class="line">  for (auto &amp;implementation : simdutf::get_available_implementations()) {</div>
<div class="line">    if (!implementation-&gt;supported_by_runtime_system()) {</div>
<div class="line">      continue;</div>
<div class="line">    }</div>
<div class="line">    bool validutf8 = implementation-&gt;validate_utf8(source.c_str(), source.size());</div>
<div class="line">    if (!validutf8) {</div>
<div class="line">      return EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; implementation-&gt;name() &lt;&lt; &quot;: &quot; &lt;&lt; implementation-&gt;description()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    chosen_implementation = implementation-&gt;name();</div>
<div class="line">  }</div>
<div class="line">  auto my_implementation =</div>
<div class="line">      simdutf::get_available_implementations()[chosen_implementation];</div>
<div class="line">  if (!my_implementation) {</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  if (!my_implementation-&gt;supported_by_runtime_system()) {</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  simdutf::get_active_implementation() = my_implementation;</div>
<div class="line">  bool validutf8 = simdutf::validate_utf8(source.c_str(), source.size());</div>
<div class="line">  if (!validutf8) {</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  if (simdutf::get_active_implementation()-&gt;name() != chosen_implementation) {</div>
<div class="line">    return EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; &quot;I have manually selected: &quot; &lt;&lt; simdutf::get_active_implementation()-&gt;name() &lt;&lt; std::endl;</div>
<div class="line">  return EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Within the simdutf library,</p>
<h2><a class="anchor" id="autotoc_md12"></a>
References</h2>
<ul>
<li>Robert Clausecker, Daniel Lemire, Transcoding Unicode Characters with AVX-512 Instructions (in preparation).</li>
<li>Daniel Lemire, Wojciech Mua, <a href="https://arxiv.org/abs/2109.10433">Transcoding Billions of Unicode Characters per Second with SIMD Instructions</a>, Software: Practice and Experience52 (2), 2022.</li>
<li>John Keiser, Daniel Lemire, <a href="https://arxiv.org/abs/2010.03090">Validating UTF-8 In Less Than One Instruction Per Byte</a>, Software: Practice and Experience 51 (5), 2021.</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
License</h2>
<p>This code is made available under the <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a> as well as the MIT license. As a user, you can pick the license you prefer.</p>
<p>We include a few competitive solutions under the benchmarks/competition directory. They are provided for research purposes only. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
