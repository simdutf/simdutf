<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdutf: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdutf
   &#160;<span id="projectnumber">5.2.3</span>
   </div>
   <div id="projectbrief">Unicode at GB/s.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">simdutf Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <a href="https://github.com/lemire/simdutf/actions/workflows/alpine.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/alpine.yml/badge.svg" alt="Alpine Linux" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/lemire/simdutf/actions/workflows/msys2.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/msys2.yml/badge.svg" alt="MSYS2-CI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/lemire/simdutf/actions/workflows/msys2-clang.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/msys2-clang.yml/badge.svg" alt="MSYS2-CLANG-CI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/lemire/simdutf/actions/workflows/ubuntu20sani.yml"><img src="https://github.com/simdutf/simdutf/actions/workflows/ubuntu20sani.yml/badge.svg" alt="Ubuntu 20.04 CI (GCC 9)" style="pointer-events: none;" class="inline"/></a> <a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&amp;can=1&amp;q=proj:simdutf"><img src="https://oss-fuzz-build-logs.storage.googleapis.com/badges/simdutf.svg" alt="Fuzzing Status" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Table of contents</h1>
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#simdutf-unicode-validation-and-transcoding-at-billions-of-characters-per-second">simdutf: Unicode validation and transcoding at billions of characters per second</a><ul>
<li><a href="#real-world-usage">Real-World Usage</a></li>
<li><a href="#how-fast-is-it">How fast is it?</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#usage-usage">Usage (Usage)</a></li>
<li><a href="#usage-cmake">Usage (CMake)</a></li>
<li><a href="#single-header-version">Single-header version</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#api">API</a></li>
<li><a href="#base64">Base64</a></li>
<li><a href="#the-sutf-command-line-tool">The sutf command-line tool</a></li>
<li><a href="#manual-implementation-selection">Manual implementation selection</a></li>
<li><a href="#references">References</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
simdutf: Unicode validation and transcoding at billions of characters per second</h1>
<p>Most modern software relies on the <a href="https://en.wikipedia.org/wiki/Unicode">Unicode standard</a>. In memory, Unicode strings are represented using either UTF-8 or UTF-16. The UTF-8 format is the de facto standard on the web (JSON, HTML, etc.) and it has been adopted as the default in many popular programming languages (Go, Rust, Swift, etc.). The UTF-16 format is standard in Java, C# and in many Windows technologies.</p>
<p>Not all sequences of bytes are valid Unicode strings. It is unsafe to use Unicode strings in UTF-8 and UTF-16LE without first validating them. Furthermore, we often need to convert strings from one encoding to another, by a process called <a href="https://en.wikipedia.org/wiki/Transcoding">transcoding</a>. For security purposes, such transcoding should be validating: it should refuse to transcode incorrect strings.</p>
<p>This library provide fast Unicode functions such as</p>
<ul>
<li>ASCII, UTF-8, UTF-16LE/BE and UTF-32 validation, with and without error identification,</li>
<li>Latin1 to UTF-8 transcoding,</li>
<li>Latin1 to UTF-16LE/BE transcoding</li>
<li>Latin1 to UTF-32 transcoding</li>
<li>UTF-8 to Latin1 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-8 to UTF-16LE/BE transcoding, with or without validation, with and without error identification,</li>
<li>UTF-8 to UTF-32 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to Latin1 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to UTF-8 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32 to Latin1 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32 to UTF-8 transcoding, with or without validation, with and without error identification,</li>
<li>UTF-32 to UTF-16LE/BE transcoding, with or without validation, with and without error identification,</li>
<li>UTF-16LE/BE to UTF-32 transcoding, with or without validation, with and without error identification,</li>
<li>From an UTF-8 string, compute the size of the Latin1 equivalent string,</li>
<li>From an UTF-8 string, compute the size of the UTF-16 equivalent string,</li>
<li>From an UTF-8 string, compute the size of the UTF-32 equivalent string (equivalent to UTF-8 character counting),</li>
<li>From an UTF-16LE/BE string, compute the size of the Latin1 equivalent string,</li>
<li>From an UTF-16LE/BE string, compute the size of the UTF-8 equivalent string,</li>
<li>From an UTF-32 string, compute the size of the UTF-8 or UTF-16LE equivalent string,</li>
<li>From an UTF-16LE/BE string, compute the size of the UTF-32 equivalent string (equivalent to UTF-16 character counting),</li>
<li>UTF-8 and UTF-16LE/BE character counting,</li>
<li>UTF-16 endianness change (UTF16-LE/BE to UTF-16-BE/LE),</li>
<li><a href="https://infra.spec.whatwg.org/#forgiving-base64-decode">WHATWG forgiving-base64</a> (with or without URL encoding) to binary,</li>
<li>Binary to base64 (with or without URL encoding).</li>
</ul>
<p>The functions are accelerated using SIMD instructions (e.g., ARM NEON, SSE, AVX, AVX-512, RISC-V Vector Extension, etc.). When your strings contain hundreds of characters, we can often transcode them at speeds exceeding a billion characters per second. You should expect high speeds not only with English strings (ASCII) but also Chinese, Japanese, Arabic, and so forth. We handle the full character range (including, for example, emojis).</p>
<p>The library compiles down to a small library of a few hundred kilobytes. Our functions are exception-free and non allocating. We have extensive tests and extensive benchmarks.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Real-World Usage</h2>
<p>The simdutf library is used by:</p><ul>
<li><a href="https://nodejs.org/en/">Node.js</a> (19.4.0 or better, 20.0 or better, 18.15 or better), a standard JavaScript runtime environment,</li>
<li><a href="https://bun.sh">Bun</a>, a fast JavaScript runtime environment,</li>
<li><a href="https://github.com/oracle/graaljs">graaljs</a>, a JavaScript implementation by Oracle,</li>
<li><a href="https://www.couchbase.com">Couchbase</a>, a popular database system,</li>
<li><a href="https://github.com/haskell/text">haskell/text</a>, a library for fast operations over Unicode text,</li>
<li><a href="https://github.com/variar/klogg">klogg</a>, a Really fast log explorer,</li>
<li><a href="https://github.com/pixie-io/pixie">Pixie</a>, observability tool for Kubernetes applications.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
How fast is it?</h2>
<p>The adoption of the simdutf library by the popular Node.js JavaScript runtime lead to a significant performance gain:</p>
<blockquote class="doxtable">
<p>Decoding and Encoding becomes considerably faster than in Node.js 18. With the addition of simdutf for UTF-8 parsing the observed benchmark, results improved by 364% (an extremely impressive leap) when decoding in comparison to Node.js 16. (<a href="https://blog.rafaelgss.dev/state-of-nodejs-performance-2023">State of Node.js Performance 2023</a>) </p>
</blockquote>
<p><img src="doc/node2023.png" alt="" width="70%" class="inline"/></p>
<p>Over a wide range of realistic data sources, the simdutf library transcodes a billion characters per second or more. Our approach can be 3 to 10 times faster than the popular ICU library on difficult (non-ASCII) strings. We can be 20x faster than ICU when processing easy strings (ASCII). Our good results apply to both recent x64 and ARM processors.</p>
<p>To illustrate, we present a benchmark result with values are in billions of characters processed by second. Consider the following figures.</p>
<p><img src="doc/utf8utf16.png" alt="" width="70%" class="inline"/></p>
<p><img src="doc/utf16utf8.png" alt="" width="70%" class="inline"/></p>
<p>If your system supports AVX-512, the simdutf library can provide very high performance. We get the following speed results on an Ice Lake Intel processor (both AVX2 and AVX-512) are simdutf kernels:</p>
<p><img src="doc/avx512.png" alt="" width="70%" class="inline"/></p>
<p>Datasets: <a href="https://github.com/lemire/unicode_lipsum">https://github.com/lemire/unicode_lipsum</a></p>
<p>Please refer to our benchmarking tool for a proper interpretation of the numbers. Our results are reproducible.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Requirements</h2>
<ul>
<li>C++11 compatible compiler. We support LLVM clang, GCC, Visual Studio. (Our optional benchmark tool requires C++17.)</li>
<li>For high speed, you should have a recent 64-bit system (e.g., ARM or x64).</li>
<li>If you rely on CMake, you should use a recent CMake (at least 3.15) ; otherwise you may use the <a href="#single-header-version">single header version</a>. The library is also available from Microsoft's vcpkg.</li>
<li>AVX-512 support require a processor with AVX512-VBMI2 (Ice Lake or better) and a recent compiler (GCC 8 or better, Visual Studio 2022 or better, LLVM clang 6 or better). You need a correspondingly recent assembler such as gas (2.30+) or nasm (2.14+): recent compilers usually come with recent assemblers. If you mix a recent compiler with an incompatible/old assembler (e.g., when using a recent compiler with an old Linux distribution), you may get errors at build time because the compiler produces instructions that the assembler does not recognize: you should update your assembler to match your compiler (e.g., upgrade binutils to version 2.30 or better under Linux) or use an older compiler matching the capabilities of your assembler.</li>
<li>To benefit from RISC-V Vector Extensions on RISC-V systems, you should compile specifically for the desired architecture. E.g., add <code>-march=rv64gcv</code> as a compiler flag when using a version of GCC or LLVM which supports these extensions (such as GCC 14 or better). The command <code>CXXFLAGS=-march=rv64gcv cmake -B build</code> may suffice.</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Usage (Usage)</h2>
<p>We made a video to help you get started with the library.</p>
<p><a href="https://www.youtube.com/watch?v=H9NZtb7ykYs"><img src="http://img.youtube.com/vi/H9NZtb7ykYs/0.jpg" alt="the simdutf library" class="inline"/></a><br  />
</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Quick Start</h2>
<p>Linux or macOS users might follow the following instructions if they have a recent C++ compiler installed and the standard utilities (<code>wget</code>, <code>unzip</code>, etc.)</p>
<ol type="1">
<li>Pull the library in a directory <div class="fragment"><div class="line">wget https://github.com/simdutf/simdutf/releases/download/v5.2.3/singleheader.zip</div>
<div class="line">unzip singleheader.zip</div>
</div><!-- fragment --></li>
<li>Compile <div class="fragment"><div class="line">c++ -std=c++17 -o amalgamation_demo amalgamation_demo.cpp</div>
</div><!-- fragment --></li>
<li><code>./amalgamation_demo</code></li>
</ol>
<div class="fragment"><div class="line">valid UTF-8</div>
<div class="line">wrote 4 UTF-16LE words.</div>
<div class="line">valid UTF-16LE</div>
<div class="line">wrote 4 UTF-8 words.</div>
<div class="line">1234</div>
<div class="line">perfect round trip</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
Usage (CMake)</h2>
<div class="fragment"><div class="line">cmake -B build</div>
<div class="line">cmake --build build</div>
<div class="line">cd build</div>
<div class="line">ctest .</div>
</div><!-- fragment --><p>Visual Studio users must specify whether they want to build the Release or Debug version.</p>
<p>To run benchmarks, execute the <code>benchmark</code> command. You can get help on its usage by first building it and then calling it with the <code>--help</code> flag. E.g., under Linux you may do the following:</p>
<div class="fragment"><div class="line">cmake -B build</div>
<div class="line">cmake --build build</div>
<div class="line">./build/benchmarks/benchmark --help</div>
</div><!-- fragment --><p>Instructions are similar for Visual Studio users.</p>
<p>To use the library as a CMake dependency in your project, please see <code>tests/installation_tests/from_fetch</code> for an example.</p>
<p>Since ICU is so common and popular, we assume that you may have it already on your system. When it is not found, it is simply omitted from the benchmarks. Thus, to benchmark against ICU, make sure you have ICU installed on your machine and that cmake can find it. For macOS, you may install it with brew using <code>brew install icu4c</code>. If you have ICU on your system but cmake cannot find it, you may need to provide cmake with a path to ICU, such as <code>ICU_ROOT=/usr/local/opt/icu4c cmake -B build</code>.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Single-header version</h2>
<p>You can create a single-header version of the library where all of the code is put into two files (<code><a class="el" href="simdutf_8h_source.html">simdutf.h</a></code> and <code>simdutf.cpp</code>). We publish a zip archive containing these files, e.g., see <a href="https://github.com/simdutf/simdutf/releases/download/v5.2.3/singleheader.zip">https://github.com/simdutf/simdutf/releases/download/v5.2.3/singleheader.zip</a></p>
<p>You may generate it on your own using a Python script.</p>
<div class="fragment"><div class="line">python3 ./singleheader/amalgamate.py</div>
</div><!-- fragment --><p>We require Python 3 or better.</p>
<p>Under Linux and macOS, you may test it as follows:</p>
<div class="fragment"><div class="line">cd singleheader</div>
<div class="line">c++ -o amalgamation_demo amalgamation_demo.cpp -std=c++17</div>
<div class="line">./amalgamation_demo</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md9"></a>
Example</h2>
<p>Using the single-header version, you could compile the following program.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;simdutf.cpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;simdutf.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *source = <span class="stringliteral">&quot;1234&quot;</span>;</div>
<div class="line">  <span class="comment">// 4 == strlen(source)</span></div>
<div class="line">  <span class="keywordtype">bool</span> validutf8 = simdutf::validate_utf8(source, 4);</div>
<div class="line">  <span class="keywordflow">if</span> (validutf8) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;valid UTF-8&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid UTF-8&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// We need a buffer of size where to write the UTF-16LE code units.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> expected_utf16words = simdutf::utf16_length_from_utf8(source, 4);</div>
<div class="line">  std::unique_ptr&lt;char16_t[]&gt; utf16_output{<span class="keyword">new</span> char16_t[expected_utf16words]};</div>
<div class="line">  <span class="comment">// convert to UTF-16LE</span></div>
<div class="line">  <span class="keywordtype">size_t</span> utf16words =</div>
<div class="line">      simdutf::convert_utf8_to_utf16le(source, 4, utf16_output.get());</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;wrote &quot;</span> &lt;&lt; utf16words &lt;&lt; <span class="stringliteral">&quot; UTF-16LE code units.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// It wrote utf16words * sizeof(char16_t) bytes.</span></div>
<div class="line">  <span class="keywordtype">bool</span> validutf16 = simdutf::validate_utf16le(utf16_output.get(), utf16words);</div>
<div class="line">  <span class="keywordflow">if</span> (validutf16) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;valid UTF-16LE&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid UTF-16LE&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// convert it back:</span></div>
<div class="line">  <span class="comment">// We need a buffer of size where to write the UTF-8 code units.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> expected_utf8words =</div>
<div class="line">      simdutf::utf8_length_from_utf16le(utf16_output.get(), utf16words);</div>
<div class="line">  std::unique_ptr&lt;char[]&gt; utf8_output{<span class="keyword">new</span> <span class="keywordtype">char</span>[expected_utf8words]};</div>
<div class="line">  <span class="comment">// convert to UTF-8</span></div>
<div class="line">  <span class="keywordtype">size_t</span> utf8words = simdutf::convert_utf16le_to_utf8(</div>
<div class="line">      utf16_output.get(), utf16words, utf8_output.get());</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;wrote &quot;</span> &lt;&lt; utf8words &lt;&lt; <span class="stringliteral">&quot; UTF-8 code units.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  std::string final_string(utf8_output.get(), utf8words);</div>
<div class="line">  std::cout &lt;&lt; final_string &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">if</span> (final_string != source) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;bad conversion&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;perfect round trip&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md10"></a>
API</h2>
<p>Our API is made of a few non-allocating functions. They typically take a pointer and a length as a parameter, and they sometimes take a pointer to an output buffer. Users are responsible for memory allocation.</p>
<p>We use three types of data pointer types:</p><ul>
<li><code>char*</code> for UTF-8 or indeterminate Unicode formats,</li>
<li><code>char16_t*</code> for UTF-16 (both UTF-16LE and UTF-16BE),</li>
<li><code>char32_t*</code> for UTF-32. UTF-32 is primarily used for internal use, not data interchange. Thus, unless otherwise stated, <code>char32_t</code> refers to the native type and is typically UTF-32LE since virtually all systems are little-endian today. In generic terms, we refer to <code>char</code>, <code>char16_t</code>, and <code>char32_t</code> as <em>code units</em>. A <em>character</em> may use several <em>code units</em>: between 1 and 4 code units in UTF-8, and between 1 and 2 code units in UTF-16LE and UTF-16BE.</li>
</ul>
<p>Our functions and declarations are all in the <code>simdutf</code> namespace. Thus you should prefix our functions and types with <code>simdutf::</code> as required.</p>
<p>We have basic functions to detect the type of an input. They return an integer defined by the following <code>enum</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> encoding_type {</div>
<div class="line">        UTF8 = 1,       <span class="comment">// BOM 0xef 0xbb 0xbf</span></div>
<div class="line">        UTF16_LE = 2,   <span class="comment">// BOM 0xff 0xfe</span></div>
<div class="line">        UTF16_BE = 4,   <span class="comment">// BOM 0xfe 0xff</span></div>
<div class="line">        UTF32_LE = 8,   <span class="comment">// BOM 0xff 0xfe 0x00 0x00</span></div>
<div class="line">        UTF32_BE = 16,   <span class="comment">// BOM 0x00 0x00 0xfe 0xff</span></div>
<div class="line"> </div>
<div class="line">        unspecified = 0</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"> </div>
<div class="line">simdutf_warn_unused simdutf::encoding_type autodetect_encoding(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">int</span> detect_encodings(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
</div><!-- fragment --><p>For validation and transcoding, we also provide functions that will stop on error and return a result struct which is a pair of two fields: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>result {</div>
<div class="line">  error_code error; <span class="comment">// see `struct error_code`.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> count; <span class="comment">// In case of error, indicates the position of the error in the input in code units.</span></div>
<div class="line">  <span class="comment">// In case of success, indicates the number of code units validated/written.</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> On error, the <code>error</code> field indicates the type of error encountered and the <code>count</code> field indicates the position of the error in the input in code units or the number of characters validated/written. We report six types of errors related to Latin1, UTF-8, UTF-16 and UTF-32 encodings: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> error_code {</div>
<div class="line">  SUCCESS = 0,</div>
<div class="line">  HEADER_BITS,  <span class="comment">// Any byte must have fewer than 5 header bits.</span></div>
<div class="line">  TOO_SHORT,    <span class="comment">// The leading byte must be followed by N-1 continuation bytes, where N is the UTF-8 character length</span></div>
<div class="line">                <span class="comment">// This is also the error when the input is truncated.</span></div>
<div class="line">  TOO_LONG,     <span class="comment">// We either have too many consecutive continuation bytes or the string starts with a continuation byte.</span></div>
<div class="line">  OVERLONG,     <span class="comment">// The decoded character must be above U+7F for two-byte characters, U+7FF for three-byte characters,</span></div>
<div class="line">                <span class="comment">// and U+FFFF for four-byte characters.</span></div>
<div class="line">  TOO_LARGE,    <span class="comment">// The decoded character must be less than or equal to U+10FFFF,less than or equal than U+7F for ASCII OR less than equal than U+FF for Latin1</span></div>
<div class="line">  SURROGATE,    <span class="comment">// The decoded character must not be in U+D800...DFFF (UTF-8 or UTF-32) OR</span></div>
<div class="line">                <span class="comment">// a high surrogate must be followed by a low surrogate and a low surrogate must be preceded by a high surrogate (UTF-16) OR</span></div>
<div class="line">                <span class="comment">// there must be no surrogate at all (Latin1)</span></div>
<div class="line">  OTHER         <span class="comment">// Not related to validation/transcoding.</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> On success, the <code>error</code> field is set to <code>SUCCESS</code> and the <code>position</code> field indicates either the number of code units validated for validation functions or the number of written code units in the output format for transcoding functions. In ASCII, Latin1 and UTF-8, code units occupy 8 bits (they are bytes); in UTF-16LE and UTF-16BE, code units occupy 16 bits; in UTF-32, code units occupy 32 bits.</p>
<p>Generally speaking, functions that report errors always stop soon after an error is encountered and might therefore be faster on inputs where an error occurs early in the input. The functions that return a boolean indicating whether or not an error has been encountered are meant to be used in an <em>optimistic setting</em>&mdash;when we expect that inputs will almost always be correct.</p>
<p>You may use functions that report an error to indicate where the problem happens during, as follows:</p>
<div class="fragment"><div class="line">std::string bad_ascii = <span class="stringliteral">&quot;\x20\x20\x20\x20\x20\xff\x20\x20\x20&quot;</span>;</div>
<div class="line"><a class="code" href="structsimdutf_1_1result.html">simdutf::result</a> res = implementation.validate_ascii_with_errors(bad_ascii.data(), bad_ascii.size());</div>
<div class="line"><span class="keywordflow">if</span>(res.error != simdutf::error_code::SUCCESS) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;error at index &quot;</span> &lt;&lt; res.count &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="astructsimdutf_1_1result_html"><div class="ttname"><a href="structsimdutf_1_1result.html">simdutf::result</a></div><div class="ttdef"><b>Definition:</b> <a href="error_8h_source.html#l00023">error.h:23</a></div></div>
</div><!-- fragment --><p>Or as follows:</p>
<div class="fragment"><div class="line">std::string bad_utf8 = <span class="stringliteral">&quot;\xc3\xa9\xc3\xa9\x20\xff\xc3\xa9&quot;</span>;</div>
<div class="line"><a class="code" href="structsimdutf_1_1result.html">simdutf::result</a> res = implementation.validate_utf8_with_errors(bad_utf8.data(), bad_utf8.size());</div>
<div class="line"><span class="keywordflow">if</span>(res.error != simdutf::error_code::SUCCESS) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;error at index &quot;</span> &lt;&lt; res.count &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line">res = implementation.validate_utf8_with_errors(bad_utf8.data(), res.count);</div>
<div class="line"><span class="comment">// will be successful in this case</span></div>
<div class="line"><span class="keywordflow">if</span>(res.error == simdutf::error_code::SUCCESS) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;we have &quot;</span> &lt;&lt; res.count &lt;&lt; <span class="stringliteral">&quot;valid bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We have fast validation functions.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">bool</span> validate_ascii(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result validate_ascii_with_errors(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">bool</span> validate_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result validate_utf8_with_errors(<span class="keyword">const</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">bool</span> validate_utf16(<span class="keyword">const</span> char16_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">bool</span> validate_utf16le(<span class="keyword">const</span> char16_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">bool</span> validate_utf16be(<span class="keyword">const</span> char16_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result validate_utf16_with_errors(<span class="keyword">const</span> char16_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result validate_utf16le_with_errors(<span class="keyword">const</span> char16_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result validate_utf16be_with_errors(<span class="keyword">const</span> char16_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">bool</span> validate_utf32(<span class="keyword">const</span> char32_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result validate_utf32_with_errors(<span class="keyword">const</span> char32_t *buf, <span class="keywordtype">size_t</span> len) noexcept;</div>
</div><!-- fragment --><p>Given a valid UTF-8 or UTF-16 input, you may count the number Unicode characters using fast functions. For UTF-32, there is no need for a function given that each character requires a flat 4 bytes. Likewise for Latin1: one byte will always equal one character.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> count_utf16(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> count_utf16le(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> count_utf16be(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> count_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
</div><!-- fragment --><p>Prior to transcoding an input, you need to allocate enough memory to receive the result. We have fast function that scan the input and compute the size of the output. These functions are fast and non-validating.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf8_length_from_latin1(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> latin1_length_from_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * Compute the number of bytes that this UTF-16LE/BE string would require in Latin1 format.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This function does not validate the input.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This function is not BOM-aware.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * @param length        the length of the string in 2-byte code units (char16_t)</span></div>
<div class="line"><span class="comment"> * @return the number of bytes required to encode the UTF-16LE string as Latin1</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> latin1_length_from_utf16(<span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> latin1_length_from_utf32(<span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf16_length_from_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf32_length_from_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf8_length_from_utf16(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf8_length_from_utf16le(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf8_length_from_utf16be(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf8_length_from_utf32(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf16_length_from_utf32(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf32_length_from_utf16(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf32_length_from_utf16le(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> utf32_length_from_utf16be(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length) noexcept;</div>
</div><!-- fragment --><p>We have a wide range of conversion between Latin1, UTF-8, UTF-16 and UTF-32. They assume that you are allocated sufficient memory for the input. The simplest conversin function output a single integer representing the size of the input, with a value of zero indicating an error (e.g., <code>convert_utf8_to_utf16le</code>). They are well suited in the scenario where you expect the input to be valid most of the time.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_latin1_to_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* utf8_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_latin1_to_utf16(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_latin1_to_utf16le(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_latin1_to_utf16be(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_latin1_to_utf32(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf8_to_latin1(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf8_to_utf16(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf8_to_utf16le(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf8_to_utf16be(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf8_to_utf32(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_output) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16_to_latin1(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16le_to_latin1(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16be_to_latin1(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16le_to_utf8(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16be_to_utf8(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf32_to_latin1(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf32_to_utf8(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf32_to_utf16(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf32_to_utf16le(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf32_to_utf16be(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16_to_utf32(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16le_to_utf32(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> convert_utf16be_to_utf32(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_buffer) noexcept;</div>
</div><!-- fragment --><p>In some cases, you need to transcode UTF-8 or UTF-16 inputs, but you may have a truncated string, meaning that the last character might be incomplete. In such cases, we recommend trimming the end of your input so you do not encounter an error.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> trim_partial_utf8(<span class="keyword">const</span> <span class="keywordtype">char</span> *input, <span class="keywordtype">size_t</span> length);</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> trim_partial_utf16be(<span class="keyword">const</span> char16_t* input, <span class="keywordtype">size_t</span> length);</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> trim_partial_utf16le(<span class="keyword">const</span> char16_t* input, <span class="keywordtype">size_t</span> length);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused <span class="keywordtype">size_t</span> trim_partial_utf16(<span class="keyword">const</span> char16_t* input, <span class="keywordtype">size_t</span> length);</div>
</div><!-- fragment --><p>You may use these <code>trim_</code> functions to decode inputs piece by piece, as in the following examples. First a case where you want to decode a UTF-8 strings in two steps:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> unicode[] = <span class="stringliteral">&quot;\xc3\xa9\x63ole d&#39;\xc3\xa9t\xc3\xa9&quot;</span>;</div>
<div class="line"><span class="comment">// suppose you want to decode only the start of this string.</span></div>
<div class="line"><span class="keywordtype">size_t</span> length = 10;</div>
<div class="line"><span class="comment">// Picking 10 bytes is problematic because we might end up in the middle of a</span></div>
<div class="line"><span class="comment">// code point. But we can rewind to the previous code point.</span></div>
<div class="line">length = simdutf::trim_partial_utf8(unicode, length);</div>
<div class="line"><span class="comment">// Now we can transcode safely</span></div>
<div class="line"><span class="keywordtype">size_t</span> budget_utf16 = simdutf::utf16_length_from_utf8(unicode, length);</div>
<div class="line">std::unique_ptr&lt;char16_t[]&gt; utf16{<span class="keyword">new</span> char16_t[budget_utf16]};</div>
<div class="line"><span class="keywordtype">size_t</span> utf16words =</div>
<div class="line">    simdutf::convert_utf8_to_utf16le(unicode, length, utf16.get());</div>
<div class="line"><span class="comment">// We can then transcode the next batch</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * next = unicode + length;</div>
<div class="line"><span class="keywordtype">size_t</span> next_length = <span class="keyword">sizeof</span>(unicode) - length;</div>
<div class="line"><span class="keywordtype">size_t</span> next_budget_utf16 = simdutf::utf16_length_from_utf8(next, next_length);</div>
<div class="line">std::unique_ptr&lt;char16_t[]&gt; next_utf16{<span class="keyword">new</span> char16_t[next_budget_utf16]};</div>
<div class="line"><span class="keywordtype">size_t</span> next_utf16words =</div>
<div class="line">    simdutf::convert_utf8_to_utf16le(next, next_length, next_utf16.get());</div>
</div><!-- fragment --><p>You can use the same approach with UTF-16:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> char16_t unicode[] = u<span class="stringliteral">&quot;\x3cd8\x10df\x3cd8\x10df\x3cd8\x10df&quot;</span>;</div>
<div class="line"><span class="comment">// suppose you want to decode only the start of this string.</span></div>
<div class="line"><span class="keywordtype">size_t</span> length = 3;</div>
<div class="line"><span class="comment">// Picking 3 units is problematic because we might end up in the middle of a</span></div>
<div class="line"><span class="comment">// surrogate pair. But we can rewind to the previous code point.</span></div>
<div class="line">length = simdutf::trim_partial_utf16(unicode, length);</div>
<div class="line"><span class="comment">// Now we can transcode safely</span></div>
<div class="line"><span class="keywordtype">size_t</span> budget_utf8 = simdutf::utf8_length_from_utf16(unicode, length);</div>
<div class="line">std::unique_ptr&lt;char[]&gt; utf8{<span class="keyword">new</span> <span class="keywordtype">char</span>[budget_utf8]};</div>
<div class="line"><span class="keywordtype">size_t</span> utf8words =</div>
<div class="line">    simdutf::convert_utf16_to_utf8(unicode, length, utf8.get());</div>
<div class="line"><span class="comment">// We can then transcode the next batch</span></div>
<div class="line"><span class="keyword">const</span> char16_t * next = unicode + length;</div>
<div class="line"><span class="keywordtype">size_t</span> next_length = 6 - length;</div>
<div class="line"><span class="keywordtype">size_t</span> next_budget_utf8 = simdutf::utf8_length_from_utf16(next, next_length);</div>
<div class="line">std::unique_ptr&lt;char[]&gt; next_utf8{<span class="keyword">new</span> <span class="keywordtype">char</span>[next_budget_utf8]};</div>
<div class="line"><span class="keywordtype">size_t</span> next_utf8words =</div>
<div class="line">    simdutf::convert_utf16_to_utf8(next, next_length, next_utf8.get());</div>
</div><!-- fragment --><p>We have more advanced conversion functions which output a <code><a class="el" href="structsimdutf_1_1result.html">simdutf::result</a></code> structure with an indication of the error type and a <code>count</code> entry (e.g., <code>convert_utf8_to_utf16le_with_errors</code>). They are well suited when you expect that there might be errors in the input that require further investigation. The <code>count</code> field contains the location of the error in the input in code units, if there is an error, or otherwise the number of code units written. You may use these functions as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// this UTF-8 string has a bad byte at index 5</span></div>
<div class="line">std::string bad_utf8 = <span class="stringliteral">&quot;\xc3\xa9\xc3\xa9\x20\xff\xc3\xa9&quot;</span>;</div>
<div class="line"><span class="keywordtype">size_t</span> budget_utf16 = simdutf::utf16_length_from_utf8(bad_utf8.data(), bad_utf8.size());</div>
<div class="line">std::unique_ptr&lt;char16_t[]&gt; utf16{<span class="keyword">new</span> char16_t[budget_utf16]};</div>
<div class="line"><a class="code" href="structsimdutf_1_1result.html">simdutf::result</a> res = simdutf::convert_utf8_to_utf16_with_errors(bad_utf8.data(), bad_utf8.size(), utf16.get());</div>
<div class="line"><span class="keywordflow">if</span>(res.error != simdutf::error_code::SUCCESS) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;error at index &quot;</span> &lt;&lt; res.count &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// the following will be successful</span></div>
<div class="line">res = simdutf::convert_utf8_to_utf16_with_errors(bad_utf8.data(), res.count, utf16.get());</div>
<div class="line"><span class="keywordflow">if</span>(res.error == simdutf::error_code::SUCCESS) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;we have transcoded &quot;</span> &lt;&lt; res.count &lt;&lt; <span class="stringliteral">&quot; characters&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We have several transcoding functions returning <code>simdutf::error</code> results:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf8_to_latin1_with_errors(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16le_to_latin1_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16be_to_latin1_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16_to_latin1_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf16_with_errors(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf16le_with_errors(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf16be_with_errors(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_output) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf8_to_utf32_with_errors(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_output) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16le_to_utf8_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16be_to_utf8_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf32_to_latin1_with_errors(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* latin1_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf8_with_errors(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, <span class="keywordtype">char</span>* utf8_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf16_with_errors(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf16le_with_errors(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf32_to_utf16be_with_errors(<span class="keyword">const</span> char32_t * input, <span class="keywordtype">size_t</span> length, char16_t* utf16_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16_to_utf32_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16le_to_utf32_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_buffer) noexcept;</div>
<div class="line"> </div>
<div class="line">simdutf_warn_unused result convert_utf16be_to_utf32_with_errors(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, char32_t* utf32_buffer) noexcept;</div>
</div><!-- fragment --><p>If you have a UTF-16 input, you may change its endianness with a fast function.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> change_endianness_utf16(<span class="keyword">const</span> char16_t * input, <span class="keywordtype">size_t</span> length, char16_t * output) noexcept;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Base64</h2>
<p>We also support converting from <a href="https://infra.spec.whatwg.org/#forgiving-base64-decode">WHATWG forgiving-base64</a> to binary, and back. In particular, you can convert base64 inputs which contain ASCII spaces to binary. We also support the base64 URL encoding alternative.</p>
<p>Converting binary data to base64 always succeeds and is relatively simple: </p><div class="fragment"><div class="line"> {C++}</div>
<div class="line">std::vector&lt;char&gt; buffer(simdutf::base64_length_from_binary(source.size()));</div>
<div class="line">simdutf::binary_to_base64(source.data(), source.size(), buffer.data());</div>
</div><!-- fragment --><p>Decoding base64 requires validation and, thus, error handling. Furthermore, because we prune spaces, we may need to adjust the result size afterword.</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line">std::vector&lt;char&gt; buffer(simdutf::maximal_binary_length_from_base64(base64.data(), base64.size()));</div>
<div class="line">simdutf::result r = simdutf::base64_to_binary(base64.data(), base64.size(), buffer.data());</div>
<div class="line">if(r.error) {</div>
<div class="line">  // We have some error, r.count tells you where the error was encountered in the input if</div>
<div class="line">  // the error is INVALID_BASE64_CHARACTER. If the error is BASE64_INPUT_REMAINDER, then</div>
<div class="line">  // a single valid base64 remained, and r.count contains the number of bytes decoded.</div>
<div class="line">} else {</div>
<div class="line">  buffer.resize(r.count); // resize the buffer according to actual number of bytes</div>
<div class="line">}</div>
</div><!-- fragment --><p>In some instances, you may want to limit the size of the output further when decoding base64. For this purpose, you may use the <code>base64_to_binary_safe</code> functions. The functions may also be useful if you seek to decode the input into segments having a maximal capacity.</p>
<div class="fragment"><div class="line">{C++}</div>
<div class="line"> size_t len = 72; // for simplicity we chose len divisible by 3</div>
<div class="line"> std::vector&lt;char&gt; base64(len, &#39;a&#39;); // we want to decode &#39;aaaaa....&#39;</div>
<div class="line"> std::vector&lt;char&gt; back((len + 3) / 4 * 3);</div>
<div class="line"> size_t limited_length = back.size() / 2; // Intentionally too small</div>
<div class="line"> // We proceed to decode half:</div>
<div class="line"> simdutf::result r = simdutf::base64_to_binary_safe(</div>
<div class="line">           base64.data(), base64.size(), back.data(), limited_length);</div>
<div class="line"> assert(r.error == simdutf::error_code::OUTPUT_BUFFER_TOO_SMALL);</div>
<div class="line"> // We decoded r.count base64 8-bit units to limited_length bytes</div>
<div class="line"> // Now let us decode the rest !!!</div>
<div class="line"> //</div>
<div class="line"> // We have read up to r.count in the input buffer and we have</div>
<div class="line"> // produced limited_length bytes.</div>
<div class="line"> //</div>
<div class="line"> size_t input_index = r.count;</div>
<div class="line"> size_t limited_length2 = back.size();</div>
<div class="line"> r = simdutf::base64_to_binary_safe(base64.data() + input_index,</div>
<div class="line">                                          base64.size() - input_index,</div>
<div class="line">                                          back.data(), limited_length2);</div>
<div class="line"> assert(r.error == simdutf::error_code::SUCCESS);</div>
<div class="line"> // We decoded r.count base64 8-bit units to limited_length2 bytes</div>
<div class="line"> // We are done</div>
<div class="line"> assert(limited_length2 + limited_length == (len + 3) / 4 * 3);</div>
</div><!-- fragment --><p>See our function specifications for more details.</p>
<p>In other instances, you may receive your base64 inputs in 16-bit units (e.g., from UTF-16 strings): we have function overloads for these cases as well.</p>
<p>Some users may want to decode the base64 inputs in chunks, especially when doing file or networking programming. These users should see <code>tools/fastbase64.cpp</code>, a command-line utility designed for as an example. It reads and writes base64 files using chunks of at most a few tens of kilobytes.</p>
<p>The specification of our base64 functions is as follows:</p>
<div class="fragment"><div class="line"> {C++}</div>
<div class="line"> </div>
<div class="line">// base64_options are used to specify the base64 encoding options.</div>
<div class="line">using base64_options = uint64_t;</div>
<div class="line">enum : base64_options {</div>
<div class="line">  base64_default = 0, /* standard base64 format */</div>
<div class="line">  base64_url = 1 /* base64url format*/</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Provide the maximal binary length in bytes given the base64 input.</div>
<div class="line"> * In general, if the input contains ASCII spaces, the result will be less than</div>
<div class="line"> * the maximum length.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the base64 input to process</div>
<div class="line"> * @param length        the length of the base64 input in bytes</div>
<div class="line"> * @return maximal number of binary bytes</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t maximal_binary_length_from_base64(const char * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Provide the maximal binary length in bytes given the base64 input.</div>
<div class="line"> * In general, if the input contains ASCII spaces, the result will be less than</div>
<div class="line"> * the maximum length.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the base64 input to process, in ASCII stored as 16-bit units</div>
<div class="line"> * @param length        the length of the base64 input in 16-bit units</div>
<div class="line"> * @return maximal number of binary bytes</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused size_t maximal_binary_length_from_base64(const char16_t * input, size_t length) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert a base64 input to a binary ouput.</div>
<div class="line"> *</div>
<div class="line"> * This function follows the WHATWG forgiving-base64 format, which means that it will</div>
<div class="line"> * ignore any ASCII spaces in the input. You may provide a padded input (with one or two</div>
<div class="line"> * equal signs at the end) or an unpadded input (without any equal signs at the end).</div>
<div class="line"> *</div>
<div class="line"> * See https://infra.spec.whatwg.org/#forgiving-base64-decode</div>
<div class="line"> *</div>
<div class="line"> * This function will fail in case of invalid input. There are two possible reasons for</div>
<div class="line"> * failure: the input contains a number of base64 characters that when divided by 4, leaves</div>
<div class="line"> * a single remainder character (BASE64_INPUT_REMAINDER), or the input contains a character</div>
<div class="line"> * that is not a valid base64 character (INVALID_BASE64_CHARACTER).</div>
<div class="line"> *</div>
<div class="line"> * The INVALID_BASE64_CHARACTER cases are considered fatal and you are expected to discard</div>
<div class="line"> * the output.</div>
<div class="line"> *</div>
<div class="line"> * When the error is INVALID_BASE64_CHARACTER, r.count contains the index in the input</div>
<div class="line"> * where the invalid character was found. When the error is BASE64_INPUT_REMAINDER, then</div>
<div class="line"> * r.count contains the number of bytes decoded.</div>
<div class="line"> *</div>
<div class="line"> * You should call this function with a buffer that is at least maximal_binary_length_from_base64(input, length) bytes long.</div>
<div class="line"> * If you fail to provide that much space, the function may cause a buffer overflow.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the base64 string to process</div>
<div class="line"> * @param length        the length of the string in bytes</div>
<div class="line"> * @param output        the pointer to buffer that can hold the conversion result (should be at least maximal_binary_length_from_base64(input, length) bytes long).</div>
<div class="line"> * @param options       the base64 options to use, can be base64_default or base64_url, is base64_default by default.</div>
<div class="line"> * @return a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the error (in the input in bytes) if any, or the number of bytes written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result base64_to_binary(const char * input, size_t length, char* output, base64_options options = base64_default) noexcept;</div>
<div class="line"> </div>
<div class="line">  /**</div>
<div class="line">   * Provide the base64 length in bytes given the length of a binary input.</div>
<div class="line">   *</div>
<div class="line">   * @param length        the length of the input in bytes</div>
<div class="line">   * @parem options       the base64 options to use, can be base64_default or base64_url, is base64_default by default.</div>
<div class="line">   * @return number of base64 bytes</div>
<div class="line">   */</div>
<div class="line">  simdutf_warn_unused size_t base64_length_from_binary(size_t length, base64_options options = base64_default) noexcept;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert a binary input to a base64 ouput. The output is always padded with equal signs so that it is</div>
<div class="line"> * a multiple of 4 bytes long.</div>
<div class="line"> *</div>
<div class="line"> * This function always succeeds.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the binary to process</div>
<div class="line"> * @param length        the length of the input in bytes</div>
<div class="line"> * @param output        the pointer to buffer that can hold the conversion result (should be at least base64_length_from_binary(length) bytes long)</div>
<div class="line"> * @param options       the base64 options to use, can be base64_default or base64_url, is base64_default by default.</div>
<div class="line"> * @return number of written bytes, will be equal to base64_length_from_binary(length)</div>
<div class="line"> */</div>
<div class="line">size_t binary_to_base64(const char * input, size_t length, char* output, base64_options options = base64_default) noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert a base64 input to a binary ouput.</div>
<div class="line"> *</div>
<div class="line"> * This function follows the WHATWG forgiving-base64 format, which means that it will</div>
<div class="line"> * ignore any ASCII spaces in the input. You may provide a padded input (with one or two</div>
<div class="line"> * equal signs at the end) or an unpadded input (without any equal signs at the end).</div>
<div class="line"> *</div>
<div class="line"> * See https://infra.spec.whatwg.org/#forgiving-base64-decode</div>
<div class="line"> *</div>
<div class="line"> * This function will fail in case of invalid input. There are two possible reasons for</div>
<div class="line"> * failure: the input contains a number of base64 characters that when divided by 4, leaves</div>
<div class="line"> * a single remainder character (BASE64_INPUT_REMAINDER), or the input contains a character</div>
<div class="line"> * that is not a valid base64 character (INVALID_BASE64_CHARACTER).</div>
<div class="line"> *</div>
<div class="line"> * When the error is INVALID_BASE64_CHARACTER, r.count contains the index in the input</div>
<div class="line"> * where the invalid character was found. When the error is BASE64_INPUT_REMAINDER, then</div>
<div class="line"> * r.count contains the number of bytes decoded.</div>
<div class="line"> *</div>
<div class="line"> * You should call this function with a buffer that is at least maximal_binary_length_from_utf6_base64(input, length) bytes long.</div>
<div class="line"> * If you fail to provide that much space, the function may cause a buffer overflow.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the base64 string to process, in ASCII stored as 16-bit units</div>
<div class="line"> * @param length        the length of the string in 16-bit units</div>
<div class="line"> * @param output        the pointer to buffer that can hold the conversion result (should be at least maximal_binary_length_from_base64(input, length) bytes long).</div>
<div class="line"> * @param options       the base64 options to use, can be base64_default or base64_url, is base64_default by default.</div>
<div class="line"> * @return a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and either position of the INVALID_BASE64_CHARACTER error (in the input in units) if any, or the number of bytes written if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result base64_to_binary(const char16_t * input, size_t length, char* output, base64_options options = base64_default)  noexcept;</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Convert a base64 input to a binary ouput.</div>
<div class="line"> *</div>
<div class="line"> * This function follows the WHATWG forgiving-base64 format, which means that it will</div>
<div class="line"> * ignore any ASCII spaces in the input. You may provide a padded input (with one or two</div>
<div class="line"> * equal signs at the end) or an unpadded input (without any equal signs at the end).</div>
<div class="line"> *</div>
<div class="line"> * See https://infra.spec.whatwg.org/#forgiving-base64-decode</div>
<div class="line"> *</div>
<div class="line"> * This function will fail in case of invalid input. There are three possible reasons for</div>
<div class="line"> * failure: the input contains a number of base64 characters that when divided by 4, leaves</div>
<div class="line"> * a single remainder character (BASE64_INPUT_REMAINDER), the input contains a character</div>
<div class="line"> * that is not a valid base64 character (INVALID_BASE64_CHARACTER), or the output buffer</div>
<div class="line"> * is too small (OUTPUT_BUFFER_TOO_SMALL).</div>
<div class="line"> *</div>
<div class="line"> * When OUTPUT_BUFFER_TOO_SMALL, we return both the number of bytes written</div>
<div class="line"> * and the number of units processed, see description of the parameters and returned value.</div>
<div class="line"> *</div>
<div class="line"> * When the error is INVALID_BASE64_CHARACTER, r.count contains the index in the input</div>
<div class="line"> * where the invalid character was found. When the error is BASE64_INPUT_REMAINDER, then</div>
<div class="line"> * r.count contains the number of bytes decoded.</div>
<div class="line"> *</div>
<div class="line"> * The INVALID_BASE64_CHARACTER cases are considered fatal and you are expected to discard</div>
<div class="line"> * the output.</div>
<div class="line"> *</div>
<div class="line"> * @param input         the base64 string to process, in ASCII stored as 8-bit or 16-bit units</div>
<div class="line"> * @param length        the length of the string in 8-bit or 16-bit units.</div>
<div class="line"> * @param output        the pointer to buffer that can hold the conversion result.</div>
<div class="line"> * @param outlen        the number of bytes that can be written in the output buffer. Upon return, it is modified to reflect how many bytes were written.</div>
<div class="line"> * @param options       the base64 options to use, can be base64_default or base64_url, is base64_default by default.</div>
<div class="line"> * @return a result pair struct (of type simdutf::error containing the two fields error and count) with an error code and position of the INVALID_BASE64_CHARACTER error (in the input in units) if any, or the number of units processed if successful.</div>
<div class="line"> */</div>
<div class="line">simdutf_warn_unused result base64_to_binary_safe(const char * input, size_t length, char* output, size_t&amp; outlen, base64_options options = base64_default) noexcept;</div>
<div class="line">simdutf_warn_unused result base64_to_binary_safe(const char16_t * input, size_t length, char* output, size_t&amp; outlen, base64_options options = base64_default) noexcept;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
The sutf command-line tool</h2>
<p>We also provide a command-line tool which can be build as follows: </p><div class="fragment"><div class="line">cmake -B build &amp;&amp; cmake --build build --target sutf</div>
</div><!-- fragment --><p> This command builds the executable in <code>./build/tool/</code> under most platforms. The sutf tool enables the user to easily transcode files from one encoding to another directly from the command line. The usage is similar to <a href="https://www.gnu.org/software/libiconv/">iconv</a> (see <code>sutf --help</code> for more details). The sutf command-line tool relies on the simdutf library functions for fast transcoding of supported formats (UTF-8, UTF-16LE, UTF-16BE and UTF-32). If iconv is found on the system and simdutf does not support a conversion, the sutf tool falls back on iconv: a message lets the user know if iconv is available during compilation. The following is an example of transcoding two input files to an output file, from UTF-8 to UTF-16LE: </p><div class="fragment"><div class="line">sutf -f UTF-8 -t UTF-16LE -o output_file.txt first_input_file.txt second_input_file.txt</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Manual implementation selection</h2>
<p>When compiling the llibrary for x64 processors, we build several implementations of each functions. At runtime, the best implementation is picked automatically. Advanced users may want to pick a particular implementation, thus bypassing our runtime detection. It is possible and even relatively convenient to do so. The following C++ program checks all the available implementation, and selects one as the default:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;simdutf.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="comment">// This is just a demonstration, not actual testing required.</span></div>
<div class="line">  std::string source = <span class="stringliteral">&quot;La vie est belle.&quot;</span>;</div>
<div class="line">  std::string chosen_implementation;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;implementation : simdutf::get_available_implementations()) {</div>
<div class="line">    <span class="keywordflow">if</span> (!implementation-&gt;supported_by_runtime_system()) {</div>
<div class="line">      <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> validutf8 = implementation-&gt;validate_utf8(source.c_str(), source.size());</div>
<div class="line">    <span class="keywordflow">if</span> (!validutf8) {</div>
<div class="line">      <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; implementation-&gt;name() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; implementation-&gt;description()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    chosen_implementation = implementation-&gt;name();</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> my_implementation =</div>
<div class="line">      simdutf::get_available_implementations()[chosen_implementation];</div>
<div class="line">  <span class="keywordflow">if</span> (!my_implementation) {</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (!my_implementation-&gt;supported_by_runtime_system()) {</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  simdutf::get_active_implementation() = my_implementation;</div>
<div class="line">  <span class="keywordtype">bool</span> validutf8 = simdutf::validate_utf8(source.c_str(), source.size());</div>
<div class="line">  <span class="keywordflow">if</span> (!validutf8) {</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (simdutf::get_active_implementation()-&gt;name() != chosen_implementation) {</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;I have manually selected: &quot;</span> &lt;&lt; simdutf::get_active_implementation()-&gt;name() &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Within the simdutf library,</p>
<h2><a class="anchor" id="autotoc_md14"></a>
References</h2>
<ul>
<li>Robert Clausecker, Daniel Lemire, <a href="https://arxiv.org/abs/2212.05098">Transcoding Unicode Characters with AVX-512 Instructions</a>, Software: Practice and Experience (to appear).</li>
<li>Daniel Lemire, Wojciech Mua, <a href="https://arxiv.org/abs/2109.10433">Transcoding Billions of Unicode Characters per Second with SIMD Instructions</a>, Software: Practice and Experience52 (2), 2022.</li>
<li>John Keiser, Daniel Lemire, <a href="https://arxiv.org/abs/2010.03090">Validating UTF-8 In Less Than One Instruction Per Byte</a>, Software: Practice and Experience 51 (5), 2021.</li>
<li>Wojciech Mua, Daniel Lemire, <a href="https://arxiv.org/abs/1910.05109">Base64 encoding and decoding at almost the speed of a memory copy</a>, Software: Practice and Experience 50 (2), 2020.</li>
<li>Wojciech Mua, Daniel Lemire, <a href="https://arxiv.org/abs/1704.00605">Faster Base64 Encoding and Decoding using AVX2 Instructions</a>, ACM Transactions on the Web 12 (3), 2018.</li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
License</h2>
<p>This code is made available under the <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache License 2.0</a> as well as the MIT license. As a user, you can pick the license you prefer.</p>
<p>We include a few competitive solutions under the benchmarks/competition directory. They are provided for research purposes only. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
