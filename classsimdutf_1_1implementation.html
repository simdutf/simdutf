<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdutf: simdutf::implementation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simdutf
   &#160;<span id="projectnumber">3.2.3</span>
   </div>
   <div id="projectbrief">Unicode at GB/s.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classsimdutf_1_1implementation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsimdutf_1_1implementation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">simdutf::implementation Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An implementation of simdutf for a particular CPU architecture.  
 <a href="classsimdutf_1_1implementation.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3281cf45b997303c89cf2d462d85d384"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3281cf45b997303c89cf2d462d85d384">name</a> () const</td></tr>
<tr class="memdesc:a3281cf45b997303c89cf2d462d85d384"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this implementation.  <a href="classsimdutf_1_1implementation.html#a3281cf45b997303c89cf2d462d85d384">More...</a><br /></td></tr>
<tr class="separator:a3281cf45b997303c89cf2d462d85d384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147dfc3a2a525074a863374ea9ea8c09"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a147dfc3a2a525074a863374ea9ea8c09">description</a> () const</td></tr>
<tr class="memdesc:a147dfc3a2a525074a863374ea9ea8c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The description of this implementation.  <a href="classsimdutf_1_1implementation.html#a147dfc3a2a525074a863374ea9ea8c09">More...</a><br /></td></tr>
<tr class="separator:a147dfc3a2a525074a863374ea9ea8c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6cd8f7d8787c76e690ed9c4151abb7a9">supported_by_runtime_system</a> () const</td></tr>
<tr class="memdesc:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The instruction sets this implementation is compiled against and the current CPU match.  <a href="classsimdutf_1_1implementation.html#a6cd8f7d8787c76e690ed9c4151abb7a9">More...</a><br /></td></tr>
<tr class="separator:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd306a0bc3e221964af3f31a64784b12"><td class="memItemLeft" align="right" valign="top">virtual encoding_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#afd306a0bc3e221964af3f31a64784b12">autodetect_encoding</a> (const char *input, size_t length) const noexcept</td></tr>
<tr class="memdesc:afd306a0bc3e221964af3f31a64784b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to detect the encoding.  <a href="classsimdutf_1_1implementation.html#afd306a0bc3e221964af3f31a64784b12">More...</a><br /></td></tr>
<tr class="separator:afd306a0bc3e221964af3f31a64784b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad4a7dbe2fbc9d03da2542c07a88cdddb">detect_encodings</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to detect the possible encodings in one pass.  <a href="classsimdutf_1_1implementation.html#ad4a7dbe2fbc9d03da2542c07a88cdddb">More...</a><br /></td></tr>
<tr class="separator:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae969eb20db2099f92a504eb7db0bcf"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aaae969eb20db2099f92a504eb7db0bcf">validate_utf8</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:aaae969eb20db2099f92a504eb7db0bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-8 string.  <a href="classsimdutf_1_1implementation.html#aaae969eb20db2099f92a504eb7db0bcf">More...</a><br /></td></tr>
<tr class="separator:aaae969eb20db2099f92a504eb7db0bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a42f53d3a9e9112a7ad4dfe67cfeccf07">validate_utf8_with_errors</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-8 string and stop on errors.  <a href="classsimdutf_1_1implementation.html#a42f53d3a9e9112a7ad4dfe67cfeccf07">More...</a><br /></td></tr>
<tr class="separator:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde94939db547675113aa71ec979d2ce"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#adde94939db547675113aa71ec979d2ce">validate_ascii</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:adde94939db547675113aa71ec979d2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the ASCII string.  <a href="classsimdutf_1_1implementation.html#adde94939db547675113aa71ec979d2ce">More...</a><br /></td></tr>
<tr class="separator:adde94939db547675113aa71ec979d2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aa73e0b4e751f59a6f67c0bde3e503e23">validate_ascii_with_errors</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the ASCII string and stop on error.  <a href="classsimdutf_1_1implementation.html#aa73e0b4e751f59a6f67c0bde3e503e23">More...</a><br /></td></tr>
<tr class="separator:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6047ac139bd2e8f6808a5bbd4b687629"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6047ac139bd2e8f6808a5bbd4b687629">validate_utf16le</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a6047ac139bd2e8f6808a5bbd4b687629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16LE string.This function may be best when you expect the input to be almost always valid.  <a href="classsimdutf_1_1implementation.html#a6047ac139bd2e8f6808a5bbd4b687629">More...</a><br /></td></tr>
<tr class="separator:a6047ac139bd2e8f6808a5bbd4b687629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a221cf4c4d195d110387d10bbd4b33"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a27a221cf4c4d195d110387d10bbd4b33">validate_utf16be</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a27a221cf4c4d195d110387d10bbd4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a27a221cf4c4d195d110387d10bbd4b33">More...</a><br /></td></tr>
<tr class="separator:a27a221cf4c4d195d110387d10bbd4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ce751bb24df472a93e4c36e8a1b03d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a53ce751bb24df472a93e4c36e8a1b03d">validate_utf16le_with_errors</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a53ce751bb24df472a93e4c36e8a1b03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16LE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a53ce751bb24df472a93e4c36e8a1b03d">More...</a><br /></td></tr>
<tr class="separator:a53ce751bb24df472a93e4c36e8a1b03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7632c87e825c7f268cbb787612e940bf"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7632c87e825c7f268cbb787612e940bf">validate_utf16be_with_errors</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a7632c87e825c7f268cbb787612e940bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16BE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a7632c87e825c7f268cbb787612e940bf">More...</a><br /></td></tr>
<tr class="separator:a7632c87e825c7f268cbb787612e940bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ab35c6765b2e4b97cc97ab9f3af52c9a9">validate_utf32</a> (const char32_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-32 string.  <a href="classsimdutf_1_1implementation.html#ab35c6765b2e4b97cc97ab9f3af52c9a9">More...</a><br /></td></tr>
<tr class="separator:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825ad7513447a16cd12f5425e2e88431"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a825ad7513447a16cd12f5425e2e88431">validate_utf32_with_errors</a> (const char32_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a825ad7513447a16cd12f5425e2e88431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a825ad7513447a16cd12f5425e2e88431">More...</a><br /></td></tr>
<tr class="separator:a825ad7513447a16cd12f5425e2e88431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487615c5d6dc00183fdf6a904bd829dc"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a487615c5d6dc00183fdf6a904bd829dc">convert_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a487615c5d6dc00183fdf6a904bd829dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a487615c5d6dc00183fdf6a904bd829dc">More...</a><br /></td></tr>
<tr class="separator:a487615c5d6dc00183fdf6a904bd829dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb08f6b1d102dd298f3d265615b21aa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0eb08f6b1d102dd298f3d265615b21aa">convert_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a0eb08f6b1d102dd298f3d265615b21aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a0eb08f6b1d102dd298f3d265615b21aa">More...</a><br /></td></tr>
<tr class="separator:a0eb08f6b1d102dd298f3d265615b21aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6091f1fbcaf897575af907ab8896d151"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6091f1fbcaf897575af907ab8896d151">convert_utf8_to_utf16le_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a6091f1fbcaf897575af907ab8896d151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a6091f1fbcaf897575af907ab8896d151">More...</a><br /></td></tr>
<tr class="separator:a6091f1fbcaf897575af907ab8896d151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e1b44673966d2f058524700d41db0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae18e1b44673966d2f058524700d41db0">convert_utf8_to_utf16be_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:ae18e1b44673966d2f058524700d41db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.  <a href="classsimdutf_1_1implementation.html#ae18e1b44673966d2f058524700d41db0">More...</a><br /></td></tr>
<tr class="separator:ae18e1b44673966d2f058524700d41db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab894ce236190e9cc71e0ce1602bbc60"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aab894ce236190e9cc71e0ce1602bbc60">convert_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_output) const noexcept=0</td></tr>
<tr class="memdesc:aab894ce236190e9cc71e0ce1602bbc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#aab894ce236190e9cc71e0ce1602bbc60">More...</a><br /></td></tr>
<tr class="separator:aab894ce236190e9cc71e0ce1602bbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5166f22c16902452eec6a93ad7a926"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5c5166f22c16902452eec6a93ad7a926">convert_utf8_to_utf32_with_errors</a> (const char *input, size_t length, char32_t *utf32_output) const noexcept=0</td></tr>
<tr class="memdesc:a5c5166f22c16902452eec6a93ad7a926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a5c5166f22c16902452eec6a93ad7a926">More...</a><br /></td></tr>
<tr class="separator:a5c5166f22c16902452eec6a93ad7a926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08870586c80a46861a25c715323402c1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a08870586c80a46861a25c715323402c1">convert_valid_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a08870586c80a46861a25c715323402c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a08870586c80a46861a25c715323402c1">More...</a><br /></td></tr>
<tr class="separator:a08870586c80a46861a25c715323402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d655f7769c5e5039821d512c116dc56"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8d655f7769c5e5039821d512c116dc56">convert_valid_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a8d655f7769c5e5039821d512c116dc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a8d655f7769c5e5039821d512c116dc56">More...</a><br /></td></tr>
<tr class="separator:a8d655f7769c5e5039821d512c116dc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7566c1718e91a6d36b0c47822b0154ad"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7566c1718e91a6d36b0c47822b0154ad">convert_valid_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a7566c1718e91a6d36b0c47822b0154ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a7566c1718e91a6d36b0c47822b0154ad">More...</a><br /></td></tr>
<tr class="separator:a7566c1718e91a6d36b0c47822b0154ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01141d4bf774c95e771924caa11efb1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae01141d4bf774c95e771924caa11efb1">utf16_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ae01141d4bf774c95e771924caa11efb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of 2-byte words that this UTF-8 string would require in UTF-16LE format.  <a href="classsimdutf_1_1implementation.html#ae01141d4bf774c95e771924caa11efb1">More...</a><br /></td></tr>
<tr class="separator:ae01141d4bf774c95e771924caa11efb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a39bc047dd50ede9cd33cb7e825eb5b56">utf32_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of 4-byte words that this UTF-8 string would require in UTF-32 format.  <a href="classsimdutf_1_1implementation.html#a39bc047dd50ede9cd33cb7e825eb5b56">More...</a><br /></td></tr>
<tr class="separator:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca86864832acad7c1277e6675c73e58"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#abca86864832acad7c1277e6675c73e58">convert_utf16le_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:abca86864832acad7c1277e6675c73e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#abca86864832acad7c1277e6675c73e58">More...</a><br /></td></tr>
<tr class="separator:abca86864832acad7c1277e6675c73e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694517e0f22276fea37d154e35648e4"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a4694517e0f22276fea37d154e35648e4">convert_utf16be_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a4694517e0f22276fea37d154e35648e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a4694517e0f22276fea37d154e35648e4">More...</a><br /></td></tr>
<tr class="separator:a4694517e0f22276fea37d154e35648e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a77cb2f67aadb85bb3c64789f3d501d8b">convert_utf16le_to_utf8_with_errors</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a77cb2f67aadb85bb3c64789f3d501d8b">More...</a><br /></td></tr>
<tr class="separator:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558db3f984286ccd44517a622f8cd676"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a558db3f984286ccd44517a622f8cd676">convert_utf16be_to_utf8_with_errors</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a558db3f984286ccd44517a622f8cd676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a558db3f984286ccd44517a622f8cd676">More...</a><br /></td></tr>
<tr class="separator:a558db3f984286ccd44517a622f8cd676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5ab12b92ea57e2b88af5b19118833b"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3d5ab12b92ea57e2b88af5b19118833b">convert_valid_utf16le_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a3d5ab12b92ea57e2b88af5b19118833b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a3d5ab12b92ea57e2b88af5b19118833b">More...</a><br /></td></tr>
<tr class="separator:a3d5ab12b92ea57e2b88af5b19118833b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204aff56bf36d384694a5b5e73ddc579"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a204aff56bf36d384694a5b5e73ddc579">convert_valid_utf16be_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a204aff56bf36d384694a5b5e73ddc579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16BE string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a204aff56bf36d384694a5b5e73ddc579">More...</a><br /></td></tr>
<tr class="separator:a204aff56bf36d384694a5b5e73ddc579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0fcdaa10985d51cd8f533c41d03c7ce0">convert_utf16le_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a0fcdaa10985d51cd8f533c41d03c7ce0">More...</a><br /></td></tr>
<tr class="separator:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297479226621edb24ffc30d642083d5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6297479226621edb24ffc30d642083d5">convert_utf16be_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a6297479226621edb24ffc30d642083d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a6297479226621edb24ffc30d642083d5">More...</a><br /></td></tr>
<tr class="separator:a6297479226621edb24ffc30d642083d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53d42cf1525497c67690667242b669d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ab53d42cf1525497c67690667242b669d">convert_utf16le_to_utf32_with_errors</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ab53d42cf1525497c67690667242b669d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#ab53d42cf1525497c67690667242b669d">More...</a><br /></td></tr>
<tr class="separator:ab53d42cf1525497c67690667242b669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f306f07f9b0c88646629efc7672bfd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a78f306f07f9b0c88646629efc7672bfd">convert_utf16be_to_utf32_with_errors</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a78f306f07f9b0c88646629efc7672bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.  <a href="classsimdutf_1_1implementation.html#a78f306f07f9b0c88646629efc7672bfd">More...</a><br /></td></tr>
<tr class="separator:a78f306f07f9b0c88646629efc7672bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5db8c4f3f4b6055497138f8cec860"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2bd5db8c4f3f4b6055497138f8cec860">convert_valid_utf16le_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a2bd5db8c4f3f4b6055497138f8cec860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-32 string.  <a href="classsimdutf_1_1implementation.html#a2bd5db8c4f3f4b6055497138f8cec860">More...</a><br /></td></tr>
<tr class="separator:a2bd5db8c4f3f4b6055497138f8cec860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e91ad7be0d09f713283d33105a4939"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a15e91ad7be0d09f713283d33105a4939">convert_valid_utf16be_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a15e91ad7be0d09f713283d33105a4939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-32BE string.  <a href="classsimdutf_1_1implementation.html#a15e91ad7be0d09f713283d33105a4939">More...</a><br /></td></tr>
<tr class="separator:a15e91ad7be0d09f713283d33105a4939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446248e71fc872b071d25a27673139f5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a446248e71fc872b071d25a27673139f5">utf8_length_from_utf16le</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a446248e71fc872b071d25a27673139f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.  <a href="classsimdutf_1_1implementation.html#a446248e71fc872b071d25a27673139f5">More...</a><br /></td></tr>
<tr class="separator:a446248e71fc872b071d25a27673139f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#abce2ef1ff8ab5ffd3999d545f703a2fd">utf8_length_from_utf16be</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.  <a href="classsimdutf_1_1implementation.html#abce2ef1ff8ab5ffd3999d545f703a2fd">More...</a><br /></td></tr>
<tr class="separator:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ac5ba1394d1cb70ff61ff9e10fec2b4ae">convert_utf32_to_utf8</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#ac5ba1394d1cb70ff61ff9e10fec2b4ae">More...</a><br /></td></tr>
<tr class="separator:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad868e852d46a46b631524f2a4bb5f31d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad868e852d46a46b631524f2a4bb5f31d">convert_utf32_to_utf8_with_errors</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ad868e852d46a46b631524f2a4bb5f31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-8 string and stop on error.  <a href="classsimdutf_1_1implementation.html#ad868e852d46a46b631524f2a4bb5f31d">More...</a><br /></td></tr>
<tr class="separator:ad868e852d46a46b631524f2a4bb5f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d859ac6b4327e3155f1accef2f42c23"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5d859ac6b4327e3155f1accef2f42c23">convert_valid_utf32_to_utf8</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a5d859ac6b4327e3155f1accef2f42c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-8 string.  <a href="classsimdutf_1_1implementation.html#a5d859ac6b4327e3155f1accef2f42c23">More...</a><br /></td></tr>
<tr class="separator:a5d859ac6b4327e3155f1accef2f42c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342d098f7c92e8344944dfa947daa66d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a342d098f7c92e8344944dfa947daa66d">convert_utf32_to_utf16le</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a342d098f7c92e8344944dfa947daa66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a342d098f7c92e8344944dfa947daa66d">More...</a><br /></td></tr>
<tr class="separator:a342d098f7c92e8344944dfa947daa66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7f90a3a4b12a2e361618fb3e9e4b5cbd">convert_utf32_to_utf16be</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a7f90a3a4b12a2e361618fb3e9e4b5cbd">More...</a><br /></td></tr>
<tr class="separator:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760d6a771de56c57588241cb01b597f"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#af760d6a771de56c57588241cb01b597f">convert_utf32_to_utf16le_with_errors</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:af760d6a771de56c57588241cb01b597f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.  <a href="classsimdutf_1_1implementation.html#af760d6a771de56c57588241cb01b597f">More...</a><br /></td></tr>
<tr class="separator:af760d6a771de56c57588241cb01b597f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3eed63c72cb1a7736ecb96f149d0ae6f">convert_utf32_to_utf16be_with_errors</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.  <a href="classsimdutf_1_1implementation.html#a3eed63c72cb1a7736ecb96f149d0ae6f">More...</a><br /></td></tr>
<tr class="separator:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a9f8ccb48c01e7f93480e9bdd7fb3beee">convert_valid_utf32_to_utf16le</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-16LE string.  <a href="classsimdutf_1_1implementation.html#a9f8ccb48c01e7f93480e9bdd7fb3beee">More...</a><br /></td></tr>
<tr class="separator:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38557c96a34c9cc87f7294aca0538582"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a38557c96a34c9cc87f7294aca0538582">convert_valid_utf32_to_utf16be</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a38557c96a34c9cc87f7294aca0538582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-16BE string.  <a href="classsimdutf_1_1implementation.html#a38557c96a34c9cc87f7294aca0538582">More...</a><br /></td></tr>
<tr class="separator:a38557c96a34c9cc87f7294aca0538582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a342c5088a3b2887485836daa92628a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8a342c5088a3b2887485836daa92628a">change_endianness_utf16</a> (const char16_t *input, size_t length, char16_t *output) const noexcept=0</td></tr>
<tr class="memdesc:a8a342c5088a3b2887485836daa92628a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the endianness of the input.  <a href="classsimdutf_1_1implementation.html#a8a342c5088a3b2887485836daa92628a">More...</a><br /></td></tr>
<tr class="separator:a8a342c5088a3b2887485836daa92628a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39ff7d49c8864a9035c626825edad0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2f39ff7d49c8864a9035c626825edad0">utf8_length_from_utf32</a> (const char32_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a2f39ff7d49c8864a9035c626825edad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-32 string would require in UTF-8 format.  <a href="classsimdutf_1_1implementation.html#a2f39ff7d49c8864a9035c626825edad0">More...</a><br /></td></tr>
<tr class="separator:a2f39ff7d49c8864a9035c626825edad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761299ce52ee8b2b480fcadc50b45a5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3761299ce52ee8b2b480fcadc50b45a5">utf16_length_from_utf32</a> (const char32_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a3761299ce52ee8b2b480fcadc50b45a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of two-byte words that this UTF-32 string would require in UTF-16 format.  <a href="classsimdutf_1_1implementation.html#a3761299ce52ee8b2b480fcadc50b45a5">More...</a><br /></td></tr>
<tr class="separator:a3761299ce52ee8b2b480fcadc50b45a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b225db7024f73fdcd6f84fb10ecdfe"><td class="memItemLeft" align="right" valign="top"><a id="a83b225db7024f73fdcd6f84fb10ecdfe"></a>
virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><b>utf32_length_from_utf16le</b> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="separator:a83b225db7024f73fdcd6f84fb10ecdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5efd699e928178cb569ee2b9b0711"><td class="memItemLeft" align="right" valign="top"><a id="a0df5efd699e928178cb569ee2b9b0711"></a>
virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><b>utf32_length_from_utf16be</b> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="separator:a0df5efd699e928178cb569ee2b9b0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612381e291d6a957707defcba3c5d4aa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a612381e291d6a957707defcba3c5d4aa">count_utf16le</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a612381e291d6a957707defcba3c5d4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <a href="classsimdutf_1_1implementation.html#a612381e291d6a957707defcba3c5d4aa">More...</a><br /></td></tr>
<tr class="separator:a612381e291d6a957707defcba3c5d4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad80712666d56ad7abb7cd8ea7862a4dd">count_utf16be</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <a href="classsimdutf_1_1implementation.html#ad80712666d56ad7abb7cd8ea7862a4dd">More...</a><br /></td></tr>
<tr class="separator:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380f5ef4b282ef66210a84ebc84bce51"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a380f5ef4b282ef66210a84ebc84bce51">count_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a380f5ef4b282ef66210a84ebc84bce51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <a href="classsimdutf_1_1implementation.html#a380f5ef4b282ef66210a84ebc84bce51">More...</a><br /></td></tr>
<tr class="separator:a380f5ef4b282ef66210a84ebc84bce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of simdutf for a particular CPU architecture. </p>
<p>Also used to maintain the currently active implementation. The active implementation is automatically initialized on first use to the most advanced implementation supported by the host. </p>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l01009">1009</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="afd306a0bc3e221964af3f31a64784b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd306a0bc3e221964af3f31a64784b12">&#9670;&nbsp;</a></span>autodetect_encoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual encoding_type simdutf::implementation::autodetect_encoding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will try to detect the encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to identify </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding type detected </dd></dl>

</div>
</div>
<a id="a8a342c5088a3b2887485836daa92628a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a342c5088a3b2887485836daa92628a">&#9670;&nbsp;</a></span>change_endianness_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void simdutf::implementation::change_endianness_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the endianness of the input. </p>
<p>Can be used to go from UTF-16LE to UTF-16BE or from UTF-16BE to UTF-16LE.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6297479226621edb24ffc30d642083d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297479226621edb24ffc30d642083d5">&#9670;&nbsp;</a></span>convert_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if input is not a valid UTF-16BE string </dd></dl>

</div>
</div>
<a id="a78f306f07f9b0c88646629efc7672bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f306f07f9b0c88646629efc7672bfd">&#9670;&nbsp;</a></span>convert_utf16be_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a4694517e0f22276fea37d154e35648e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4694517e0f22276fea37d154e35648e4">&#9670;&nbsp;</a></span>convert_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if input is not a valid UTF-16BE string </dd></dl>

</div>
</div>
<a id="a558db3f984286ccd44517a622f8cd676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558db3f984286ccd44517a622f8cd676">&#9670;&nbsp;</a></span>convert_utf16be_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a0fcdaa10985d51cd8f533c41d03c7ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdaa10985d51cd8f533c41d03c7ce0">&#9670;&nbsp;</a></span>convert_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="ab53d42cf1525497c67690667242b669d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53d42cf1525497c67690667242b669d">&#9670;&nbsp;</a></span>convert_utf16le_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="abca86864832acad7c1277e6675c73e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca86864832acad7c1277e6675c73e58">&#9670;&nbsp;</a></span>convert_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a77cb2f67aadb85bb3c64789f3d501d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cb2f67aadb85bb3c64789f3d501d8b">&#9670;&nbsp;</a></span>convert_utf16le_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a7f90a3a4b12a2e361618fb3e9e4b5cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f90a3a4b12a2e361618fb3e9e4b5cbd">&#9670;&nbsp;</a></span>convert_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16BE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a3eed63c72cb1a7736ecb96f149d0ae6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eed63c72cb1a7736ecb96f149d0ae6f">&#9670;&nbsp;</a></span>convert_utf32_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16BE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="a342d098f7c92e8344944dfa947daa66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342d098f7c92e8344944dfa947daa66d">&#9670;&nbsp;</a></span>convert_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16LE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="af760d6a771de56c57588241cb01b597f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af760d6a771de56c57588241cb01b597f">&#9670;&nbsp;</a></span>convert_utf32_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16LE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="ac5ba1394d1cb70ff61ff9e10fec2b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ba1394d1cb70ff61ff9e10fec2b4ae">&#9670;&nbsp;</a></span>convert_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="ad868e852d46a46b631524f2a4bb5f31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad868e852d46a46b631524f2a4bb5f31d">&#9670;&nbsp;</a></span>convert_utf32_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a0eb08f6b1d102dd298f3d265615b21aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb08f6b1d102dd298f3d265615b21aa">&#9670;&nbsp;</a></span>convert_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16BE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="ae18e1b44673966d2f058524700d41db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18e1b44673966d2f058524700d41db0">&#9670;&nbsp;</a></span>convert_utf8_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16BE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of words validated if successful. </dd></dl>

</div>
</div>
<a id="a487615c5d6dc00183fdf6a904bd829dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487615c5d6dc00183fdf6a904bd829dc">&#9670;&nbsp;</a></span>convert_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16LE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a6091f1fbcaf897575af907ab8896d151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6091f1fbcaf897575af907ab8896d151">&#9670;&nbsp;</a></span>convert_utf8_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16LE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of words validated if successful. </dd></dl>

</div>
</div>
<a id="aab894ce236190e9cc71e0ce1602bbc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab894ce236190e9cc71e0ce1602bbc60">&#9670;&nbsp;</a></span>convert_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a5c5166f22c16902452eec6a93ad7a926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5166f22c16902452eec6a93ad7a926">&#9670;&nbsp;</a></span>convert_utf8_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a15e91ad7be0d09f713283d33105a4939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e91ad7be0d09f713283d33105a4939">&#9670;&nbsp;</a></span>convert_valid_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-32BE string. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a204aff56bf36d384694a5b5e73ddc579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204aff56bf36d384694a5b5e73ddc579">&#9670;&nbsp;</a></span>convert_valid_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16BE string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a2bd5db8c4f3f4b6055497138f8cec860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd5db8c4f3f4b6055497138f8cec860">&#9670;&nbsp;</a></span>convert_valid_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-32 string. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a3d5ab12b92ea57e2b88af5b19118833b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5ab12b92ea57e2b88af5b19118833b">&#9670;&nbsp;</a></span>convert_valid_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a38557c96a34c9cc87f7294aca0538582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38557c96a34c9cc87f7294aca0538582">&#9670;&nbsp;</a></span>convert_valid_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-16BE string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a9f8ccb48c01e7f93480e9bdd7fb3beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8ccb48c01e7f93480e9bdd7fb3beee">&#9670;&nbsp;</a></span>convert_valid_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-16LE string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a5d859ac6b4327e3155f1accef2f42c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d859ac6b4327e3155f1accef2f42c23">&#9670;&nbsp;</a></span>convert_valid_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written words; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a8d655f7769c5e5039821d512c116dc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d655f7769c5e5039821d512c116dc56">&#9670;&nbsp;</a></span>convert_valid_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-16BE string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a08870586c80a46861a25c715323402c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08870586c80a46861a25c715323402c1">&#9670;&nbsp;</a></span>convert_valid_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-16LE string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a7566c1718e91a6d36b0c47822b0154ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7566c1718e91a6d36b0c47822b0154ad">&#9670;&nbsp;</a></span>convert_valid_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-32 string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t </dd></dl>

</div>
</div>
<a id="ad80712666d56ad7abb7cd8ea7862a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80712666d56ad7abb7cd8ea7862a4dd">&#9670;&nbsp;</a></span>count_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a612381e291d6a957707defcba3c5d4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612381e291d6a957707defcba3c5d4aa">&#9670;&nbsp;</a></span>count_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a380f5ef4b282ef66210a84ebc84bce51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380f5ef4b282ef66210a84ebc84bce51">&#9670;&nbsp;</a></span>count_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a147dfc3a2a525074a863374ea9ea8c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147dfc3a2a525074a863374ea9ea8c09">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; simdutf::implementation::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The description of this implementation. </p>
<pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt; impl-&gt;description() &lt;&lt; ")" &lt;&lt; endl;
</pre> <dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l01030">1030</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="ad4a7dbe2fbc9d03da2542c07a88cdddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a7dbe2fbc9d03da2542c07a88cdddb">&#9670;&nbsp;</a></span>detect_encodings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int simdutf::implementation::detect_encodings </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will try to detect the possible encodings in one pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to identify </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding type detected </dd></dl>

</div>
</div>
<a id="a3281cf45b997303c89cf2d462d85d384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3281cf45b997303c89cf2d462d85d384">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; simdutf::implementation::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of this implementation. </p>
<pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt; impl-&gt;description() &lt;&lt; ")" &lt;&lt; endl;
</pre> <dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l01020">1020</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="a6cd8f7d8787c76e690ed9c4151abb7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd8f7d8787c76e690ed9c4151abb7a9">&#9670;&nbsp;</a></span>supported_by_runtime_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool simdutf::implementation::supported_by_runtime_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The instruction sets this implementation is compiled against and the current CPU match. </p>
<p>This function may poll the current CPU/system and should therefore not be called too often if performance is a concern.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the implementation can be safely used on the current system (determined at runtime) </dd></dl>

</div>
</div>
<a id="a3761299ce52ee8b2b480fcadc50b45a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3761299ce52ee8b2b480fcadc50b45a5">&#9670;&nbsp;</a></span>utf16_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of two-byte words that this UTF-32 string would require in UTF-16 format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-16 </dd></dl>

</div>
</div>
<a id="ae01141d4bf774c95e771924caa11efb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01141d4bf774c95e771924caa11efb1">&#9670;&nbsp;</a></span>utf16_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of 2-byte words that this UTF-8 string would require in UTF-16LE format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char16_t words required to encode the UTF-8 string as UTF-16LE </dd></dl>

</div>
</div>
<a id="a39bc047dd50ede9cd33cb7e825eb5b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bc047dd50ede9cd33cb7e825eb5b56">&#9670;&nbsp;</a></span>utf32_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf32_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of 4-byte words that this UTF-8 string would require in UTF-32 format. </p>
<p>This function is equivalent to count_utf8.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char32_t words required to encode the UTF-8 string as UTF-32 </dd></dl>

</div>
</div>
<a id="abce2ef1ff8ab5ffd3999d545f703a2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce2ef1ff8ab5ffd3999d545f703a2fd">&#9670;&nbsp;</a></span>utf8_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16BE string would require in UTF-8 format. </p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16BE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a446248e71fc872b071d25a27673139f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446248e71fc872b071d25a27673139f5">&#9670;&nbsp;</a></span>utf8_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16LE string would require in UTF-8 format. </p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte words (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a2f39ff7d49c8864a9035c626825edad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f39ff7d49c8864a9035c626825edad0">&#9670;&nbsp;</a></span>utf8_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-32 string would require in UTF-8 format. </p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte words (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-8 </dd></dl>

</div>
</div>
<a id="adde94939db547675113aa71ec979d2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde94939db547675113aa71ec979d2ce">&#9670;&nbsp;</a></span>validate_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_ascii </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the ASCII string. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid ASCII. </dd></dl>

</div>
</div>
<a id="aa73e0b4e751f59a6f67c0bde3e503e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e0b4e751f59a6f67c0bde3e503e23">&#9670;&nbsp;</a></span>validate_ascii_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_ascii_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the ASCII string and stop on error. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of words validated if successful. </dd></dl>

</div>
</div>
<a id="a27a221cf4c4d195d110387d10bbd4b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a221cf4c4d195d110387d10bbd4b33">&#9670;&nbsp;</a></span>validate_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16BE string. </p>
<p>This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16be_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte words (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16BE. </dd></dl>

</div>
</div>
<a id="a7632c87e825c7f268cbb787612e940bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7632c87e825c7f268cbb787612e940bf">&#9670;&nbsp;</a></span>validate_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16BE string and stop on error. </p>
<p>It might be faster than validate_utf16be when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte words (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of words validated if successful. </dd></dl>

</div>
</div>
<a id="a6047ac139bd2e8f6808a5bbd4b687629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6047ac139bd2e8f6808a5bbd4b687629">&#9670;&nbsp;</a></span>validate_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16LE string.This function may be best when you expect the input to be almost always valid. </p>
<p>Otherwise, consider using validate_utf16le_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte words (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16LE. </dd></dl>

</div>
</div>
<a id="a53ce751bb24df472a93e4c36e8a1b03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ce751bb24df472a93e4c36e8a1b03d">&#9670;&nbsp;</a></span>validate_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16LE string and stop on error. </p>
<p>It might be faster than validate_utf16le when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte words (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of words validated if successful. </dd></dl>

</div>
</div>
<a id="ab35c6765b2e4b97cc97ab9f3af52c9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35c6765b2e4b97cc97ab9f3af52c9a9">&#9670;&nbsp;</a></span>validate_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-32 string. </p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte words (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-32. </dd></dl>

</div>
</div>
<a id="a825ad7513447a16cd12f5425e2e88431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825ad7513447a16cd12f5425e2e88431">&#9670;&nbsp;</a></span>validate_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-32 string and stop on error. </p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte words (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of words validated if successful. </dd></dl>

</div>
</div>
<a id="aaae969eb20db2099f92a504eb7db0bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae969eb20db2099f92a504eb7db0bcf">&#9670;&nbsp;</a></span>validate_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-8 string. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-8. </dd></dl>

</div>
</div>
<a id="a42f53d3a9e9112a7ad4dfe67cfeccf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f53d3a9e9112a7ad4dfe67cfeccf07">&#9670;&nbsp;</a></span>validate_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-8 string and stop on errors. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct with an error code and either the position of the error if any or the number of words validated if successful. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/simdutf/<a class="el" href="implementation_8h_source.html">implementation.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>simdutf</b></li><li class="navelem"><a class="el" href="classsimdutf_1_1implementation.html">implementation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
