<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simdutf: simdutf::implementation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">simdutf<span id="projectnumber">&#160;7.3.5</span>
   </div>
   <div id="projectbrief">Unicode at GB/s.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classsimdutf_1_1implementation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsimdutf_1_1implementation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">simdutf::implementation Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>An implementation of simdutf for a particular CPU architecture.  
 <a href="classsimdutf_1_1implementation.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="implementation_8h_source.html">implementation.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5bf5083338ae14df38af6661041e53b" id="r_aa5bf5083338ae14df38af6661041e53b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aa5bf5083338ae14df38af6661041e53b">name</a> () const</td></tr>
<tr class="memdesc:aa5bf5083338ae14df38af6661041e53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this implementation.  <br /></td></tr>
<tr class="separator:aa5bf5083338ae14df38af6661041e53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48e75e8d6d25c3c3d66334a8849cbc7" id="r_af48e75e8d6d25c3c3d66334a8849cbc7"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#af48e75e8d6d25c3c3d66334a8849cbc7">description</a> () const</td></tr>
<tr class="memdesc:af48e75e8d6d25c3c3d66334a8849cbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The description of this implementation.  <br /></td></tr>
<tr class="separator:af48e75e8d6d25c3c3d66334a8849cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd8f7d8787c76e690ed9c4151abb7a9" id="r_a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6cd8f7d8787c76e690ed9c4151abb7a9">supported_by_runtime_system</a> () const</td></tr>
<tr class="memdesc:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The instruction sets this implementation is compiled against and the current CPU match.  <br /></td></tr>
<tr class="separator:a6cd8f7d8787c76e690ed9c4151abb7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd306a0bc3e221964af3f31a64784b12" id="r_afd306a0bc3e221964af3f31a64784b12"><td class="memItemLeft" align="right" valign="top">virtual encoding_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#afd306a0bc3e221964af3f31a64784b12">autodetect_encoding</a> (const char *input, size_t length) const noexcept</td></tr>
<tr class="memdesc:afd306a0bc3e221964af3f31a64784b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to detect the encoding.  <br /></td></tr>
<tr class="separator:afd306a0bc3e221964af3f31a64784b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a7dbe2fbc9d03da2542c07a88cdddb" id="r_ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad4a7dbe2fbc9d03da2542c07a88cdddb">detect_encodings</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to detect the possible encodings in one pass.  <br /></td></tr>
<tr class="separator:ad4a7dbe2fbc9d03da2542c07a88cdddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae969eb20db2099f92a504eb7db0bcf" id="r_aaae969eb20db2099f92a504eb7db0bcf"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aaae969eb20db2099f92a504eb7db0bcf">validate_utf8</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:aaae969eb20db2099f92a504eb7db0bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-8 string.  <br /></td></tr>
<tr class="separator:aaae969eb20db2099f92a504eb7db0bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f53d3a9e9112a7ad4dfe67cfeccf07" id="r_a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a42f53d3a9e9112a7ad4dfe67cfeccf07">validate_utf8_with_errors</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-8 string and stop on errors.  <br /></td></tr>
<tr class="separator:a42f53d3a9e9112a7ad4dfe67cfeccf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde94939db547675113aa71ec979d2ce" id="r_adde94939db547675113aa71ec979d2ce"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#adde94939db547675113aa71ec979d2ce">validate_ascii</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:adde94939db547675113aa71ec979d2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the ASCII string.  <br /></td></tr>
<tr class="separator:adde94939db547675113aa71ec979d2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73e0b4e751f59a6f67c0bde3e503e23" id="r_aa73e0b4e751f59a6f67c0bde3e503e23"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aa73e0b4e751f59a6f67c0bde3e503e23">validate_ascii_with_errors</a> (const char *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the ASCII string and stop on error.  <br /></td></tr>
<tr class="separator:aa73e0b4e751f59a6f67c0bde3e503e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6047ac139bd2e8f6808a5bbd4b687629" id="r_a6047ac139bd2e8f6808a5bbd4b687629"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6047ac139bd2e8f6808a5bbd4b687629">validate_utf16le</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a6047ac139bd2e8f6808a5bbd4b687629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16LE string.This function may be best when you expect the input to be almost always valid.  <br /></td></tr>
<tr class="separator:a6047ac139bd2e8f6808a5bbd4b687629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a221cf4c4d195d110387d10bbd4b33" id="r_a27a221cf4c4d195d110387d10bbd4b33"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a27a221cf4c4d195d110387d10bbd4b33">validate_utf16be</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a27a221cf4c4d195d110387d10bbd4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16BE string.  <br /></td></tr>
<tr class="separator:a27a221cf4c4d195d110387d10bbd4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ce751bb24df472a93e4c36e8a1b03d" id="r_a53ce751bb24df472a93e4c36e8a1b03d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a53ce751bb24df472a93e4c36e8a1b03d">validate_utf16le_with_errors</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a53ce751bb24df472a93e4c36e8a1b03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16LE string and stop on error.  <br /></td></tr>
<tr class="separator:a53ce751bb24df472a93e4c36e8a1b03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7632c87e825c7f268cbb787612e940bf" id="r_a7632c87e825c7f268cbb787612e940bf"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7632c87e825c7f268cbb787612e940bf">validate_utf16be_with_errors</a> (const char16_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a7632c87e825c7f268cbb787612e940bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-16BE string and stop on error.  <br /></td></tr>
<tr class="separator:a7632c87e825c7f268cbb787612e940bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8b3a891225e204cb9e98fbea8a7dab" id="r_a3d8b3a891225e204cb9e98fbea8a7dab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3d8b3a891225e204cb9e98fbea8a7dab">to_well_formed_utf16le</a> (const char16_t *input, size_t len, char16_t *output) const noexcept=0</td></tr>
<tr class="memdesc:a3d8b3a891225e204cb9e98fbea8a7dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the UTF-16LE string while replacing mismatched surrogates with the Unicode replacement character U+FFFD.  <br /></td></tr>
<tr class="separator:a3d8b3a891225e204cb9e98fbea8a7dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf5488b9e07462f004b8aa819b85e73" id="r_adaf5488b9e07462f004b8aa819b85e73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#adaf5488b9e07462f004b8aa819b85e73">to_well_formed_utf16be</a> (const char16_t *input, size_t len, char16_t *output) const noexcept=0</td></tr>
<tr class="memdesc:adaf5488b9e07462f004b8aa819b85e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the UTF-16BE string while replacing mismatched surrogates with the Unicode replacement character U+FFFD.  <br /></td></tr>
<tr class="separator:adaf5488b9e07462f004b8aa819b85e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35c6765b2e4b97cc97ab9f3af52c9a9" id="r_ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ab35c6765b2e4b97cc97ab9f3af52c9a9">validate_utf32</a> (const char32_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-32 string.  <br /></td></tr>
<tr class="separator:ab35c6765b2e4b97cc97ab9f3af52c9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825ad7513447a16cd12f5425e2e88431" id="r_a825ad7513447a16cd12f5425e2e88431"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a825ad7513447a16cd12f5425e2e88431">validate_utf32_with_errors</a> (const char32_t *buf, size_t len) const noexcept=0</td></tr>
<tr class="memdesc:a825ad7513447a16cd12f5425e2e88431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the UTF-32 string and stop on error.  <br /></td></tr>
<tr class="separator:a825ad7513447a16cd12f5425e2e88431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79deb79661a71f145b7bc6786fe4223" id="r_af79deb79661a71f145b7bc6786fe4223"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#af79deb79661a71f145b7bc6786fe4223">convert_latin1_to_utf8</a> (const char *input, size_t length, char *utf8_output) const noexcept=0</td></tr>
<tr class="memdesc:af79deb79661a71f145b7bc6786fe4223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Latin1 string into UTF-8 string.  <br /></td></tr>
<tr class="separator:af79deb79661a71f145b7bc6786fe4223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2315da3daf654f4a7132b1751394b374" id="r_a2315da3daf654f4a7132b1751394b374"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2315da3daf654f4a7132b1751394b374">convert_latin1_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a2315da3daf654f4a7132b1751394b374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly Latin1 string into UTF-16LE string.  <br /></td></tr>
<tr class="separator:a2315da3daf654f4a7132b1751394b374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f498ad9236b916e5e4859109d1df0bb" id="r_a2f498ad9236b916e5e4859109d1df0bb"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2f498ad9236b916e5e4859109d1df0bb">convert_latin1_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a2f498ad9236b916e5e4859109d1df0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Latin1 string into UTF-16BE string.  <br /></td></tr>
<tr class="separator:a2f498ad9236b916e5e4859109d1df0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb5a0db793a6e332711c24d9cbc14fd" id="r_a5bb5a0db793a6e332711c24d9cbc14fd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5bb5a0db793a6e332711c24d9cbc14fd">convert_latin1_to_utf32</a> (const char *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a5bb5a0db793a6e332711c24d9cbc14fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Latin1 string into UTF-32 string.  <br /></td></tr>
<tr class="separator:a5bb5a0db793a6e332711c24d9cbc14fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c2c1418f08f84e36c22727879db307" id="r_ac9c2c1418f08f84e36c22727879db307"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ac9c2c1418f08f84e36c22727879db307">convert_utf8_to_latin1</a> (const char *input, size_t length, char *latin1_output) const noexcept=0</td></tr>
<tr class="memdesc:ac9c2c1418f08f84e36c22727879db307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into latin1 string.  <br /></td></tr>
<tr class="separator:ac9c2c1418f08f84e36c22727879db307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae845d016f715c25475970c4dfcb58a8d" id="r_ae845d016f715c25475970c4dfcb58a8d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae845d016f715c25475970c4dfcb58a8d">convert_utf8_to_latin1_with_errors</a> (const char *input, size_t length, char *latin1_output) const noexcept=0</td></tr>
<tr class="memdesc:ae845d016f715c25475970c4dfcb58a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into latin1 string with errors.  <br /></td></tr>
<tr class="separator:ae845d016f715c25475970c4dfcb58a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903279159cb5f5e0e767cce6f1440889" id="r_a903279159cb5f5e0e767cce6f1440889"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a903279159cb5f5e0e767cce6f1440889">convert_valid_utf8_to_latin1</a> (const char *input, size_t length, char *latin1_output) const noexcept=0</td></tr>
<tr class="memdesc:a903279159cb5f5e0e767cce6f1440889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into latin1 string.  <br /></td></tr>
<tr class="separator:a903279159cb5f5e0e767cce6f1440889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487615c5d6dc00183fdf6a904bd829dc" id="r_a487615c5d6dc00183fdf6a904bd829dc"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a487615c5d6dc00183fdf6a904bd829dc">convert_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a487615c5d6dc00183fdf6a904bd829dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16LE string.  <br /></td></tr>
<tr class="separator:a487615c5d6dc00183fdf6a904bd829dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb08f6b1d102dd298f3d265615b21aa" id="r_a0eb08f6b1d102dd298f3d265615b21aa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0eb08f6b1d102dd298f3d265615b21aa">convert_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a0eb08f6b1d102dd298f3d265615b21aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16BE string.  <br /></td></tr>
<tr class="separator:a0eb08f6b1d102dd298f3d265615b21aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6091f1fbcaf897575af907ab8896d151" id="r_a6091f1fbcaf897575af907ab8896d151"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6091f1fbcaf897575af907ab8896d151">convert_utf8_to_utf16le_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:a6091f1fbcaf897575af907ab8896d151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16LE string and stop on error.  <br /></td></tr>
<tr class="separator:a6091f1fbcaf897575af907ab8896d151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e1b44673966d2f058524700d41db0" id="r_ae18e1b44673966d2f058524700d41db0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae18e1b44673966d2f058524700d41db0">convert_utf8_to_utf16be_with_errors</a> (const char *input, size_t length, char16_t *utf16_output) const noexcept=0</td></tr>
<tr class="memdesc:ae18e1b44673966d2f058524700d41db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-16BE string and stop on error.  <br /></td></tr>
<tr class="separator:ae18e1b44673966d2f058524700d41db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab894ce236190e9cc71e0ce1602bbc60" id="r_aab894ce236190e9cc71e0ce1602bbc60"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aab894ce236190e9cc71e0ce1602bbc60">convert_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_output) const noexcept=0</td></tr>
<tr class="memdesc:aab894ce236190e9cc71e0ce1602bbc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-32 string.  <br /></td></tr>
<tr class="separator:aab894ce236190e9cc71e0ce1602bbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5166f22c16902452eec6a93ad7a926" id="r_a5c5166f22c16902452eec6a93ad7a926"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5c5166f22c16902452eec6a93ad7a926">convert_utf8_to_utf32_with_errors</a> (const char *input, size_t length, char32_t *utf32_output) const noexcept=0</td></tr>
<tr class="memdesc:a5c5166f22c16902452eec6a93ad7a926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-8 string into UTF-32 string and stop on error.  <br /></td></tr>
<tr class="separator:a5c5166f22c16902452eec6a93ad7a926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08870586c80a46861a25c715323402c1" id="r_a08870586c80a46861a25c715323402c1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a08870586c80a46861a25c715323402c1">convert_valid_utf8_to_utf16le</a> (const char *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a08870586c80a46861a25c715323402c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-16LE string.  <br /></td></tr>
<tr class="separator:a08870586c80a46861a25c715323402c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d655f7769c5e5039821d512c116dc56" id="r_a8d655f7769c5e5039821d512c116dc56"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8d655f7769c5e5039821d512c116dc56">convert_valid_utf8_to_utf16be</a> (const char *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a8d655f7769c5e5039821d512c116dc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-16BE string.  <br /></td></tr>
<tr class="separator:a8d655f7769c5e5039821d512c116dc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7566c1718e91a6d36b0c47822b0154ad" id="r_a7566c1718e91a6d36b0c47822b0154ad"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7566c1718e91a6d36b0c47822b0154ad">convert_valid_utf8_to_utf32</a> (const char *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a7566c1718e91a6d36b0c47822b0154ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-8 string into UTF-32 string.  <br /></td></tr>
<tr class="separator:a7566c1718e91a6d36b0c47822b0154ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01141d4bf774c95e771924caa11efb1" id="r_ae01141d4bf774c95e771924caa11efb1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ae01141d4bf774c95e771924caa11efb1">utf16_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ae01141d4bf774c95e771924caa11efb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of 2-byte code units that this UTF-8 string would require in UTF-16LE format.  <br /></td></tr>
<tr class="separator:ae01141d4bf774c95e771924caa11efb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bc047dd50ede9cd33cb7e825eb5b56" id="r_a39bc047dd50ede9cd33cb7e825eb5b56"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a39bc047dd50ede9cd33cb7e825eb5b56">utf32_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of 4-byte code units that this UTF-8 string would require in UTF-32 format.  <br /></td></tr>
<tr class="separator:a39bc047dd50ede9cd33cb7e825eb5b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f16dc0f3bdd4457425898a17c51d45" id="r_a75f16dc0f3bdd4457425898a17c51d45"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a75f16dc0f3bdd4457425898a17c51d45">convert_utf16le_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a75f16dc0f3bdd4457425898a17c51d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into Latin1 string.  <br /></td></tr>
<tr class="separator:a75f16dc0f3bdd4457425898a17c51d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac941440407fed1518a179f1d0396720c" id="r_ac941440407fed1518a179f1d0396720c"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ac941440407fed1518a179f1d0396720c">convert_utf16be_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ac941440407fed1518a179f1d0396720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into Latin1 string.  <br /></td></tr>
<tr class="separator:ac941440407fed1518a179f1d0396720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa4c4b831e691e623552bbf9c60b801" id="r_a4aa4c4b831e691e623552bbf9c60b801"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a4aa4c4b831e691e623552bbf9c60b801">convert_utf16le_to_latin1_with_errors</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a4aa4c4b831e691e623552bbf9c60b801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into Latin1 string.  <br /></td></tr>
<tr class="separator:a4aa4c4b831e691e623552bbf9c60b801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a8022ac1760f081d389cb00a4dac80" id="r_a29a8022ac1760f081d389cb00a4dac80"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a29a8022ac1760f081d389cb00a4dac80">convert_utf16be_to_latin1_with_errors</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a29a8022ac1760f081d389cb00a4dac80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into Latin1 string.  <br /></td></tr>
<tr class="separator:a29a8022ac1760f081d389cb00a4dac80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c8a9e58f4c111d52851e4fdbca0af1" id="r_a65c8a9e58f4c111d52851e4fdbca0af1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a65c8a9e58f4c111d52851e4fdbca0af1">convert_valid_utf16le_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a65c8a9e58f4c111d52851e4fdbca0af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into Latin1 string.  <br /></td></tr>
<tr class="separator:a65c8a9e58f4c111d52851e4fdbca0af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6896e27fd7fe773ba25bfaed081aafaa" id="r_a6896e27fd7fe773ba25bfaed081aafaa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6896e27fd7fe773ba25bfaed081aafaa">convert_valid_utf16be_to_latin1</a> (const char16_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a6896e27fd7fe773ba25bfaed081aafaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16BE string into Latin1 string.  <br /></td></tr>
<tr class="separator:a6896e27fd7fe773ba25bfaed081aafaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca86864832acad7c1277e6675c73e58" id="r_abca86864832acad7c1277e6675c73e58"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#abca86864832acad7c1277e6675c73e58">convert_utf16le_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:abca86864832acad7c1277e6675c73e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-8 string.  <br /></td></tr>
<tr class="separator:abca86864832acad7c1277e6675c73e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4694517e0f22276fea37d154e35648e4" id="r_a4694517e0f22276fea37d154e35648e4"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a4694517e0f22276fea37d154e35648e4">convert_utf16be_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a4694517e0f22276fea37d154e35648e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-8 string.  <br /></td></tr>
<tr class="separator:a4694517e0f22276fea37d154e35648e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cb2f67aadb85bb3c64789f3d501d8b" id="r_a77cb2f67aadb85bb3c64789f3d501d8b"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a77cb2f67aadb85bb3c64789f3d501d8b">convert_utf16le_to_utf8_with_errors</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-8 string and stop on error.  <br /></td></tr>
<tr class="separator:a77cb2f67aadb85bb3c64789f3d501d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558db3f984286ccd44517a622f8cd676" id="r_a558db3f984286ccd44517a622f8cd676"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a558db3f984286ccd44517a622f8cd676">convert_utf16be_to_utf8_with_errors</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a558db3f984286ccd44517a622f8cd676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-8 string and stop on error.  <br /></td></tr>
<tr class="separator:a558db3f984286ccd44517a622f8cd676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5ab12b92ea57e2b88af5b19118833b" id="r_a3d5ab12b92ea57e2b88af5b19118833b"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3d5ab12b92ea57e2b88af5b19118833b">convert_valid_utf16le_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a3d5ab12b92ea57e2b88af5b19118833b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-8 string.  <br /></td></tr>
<tr class="separator:a3d5ab12b92ea57e2b88af5b19118833b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204aff56bf36d384694a5b5e73ddc579" id="r_a204aff56bf36d384694a5b5e73ddc579"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a204aff56bf36d384694a5b5e73ddc579">convert_valid_utf16be_to_utf8</a> (const char16_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a204aff56bf36d384694a5b5e73ddc579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16BE string into UTF-8 string.  <br /></td></tr>
<tr class="separator:a204aff56bf36d384694a5b5e73ddc579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdaa10985d51cd8f533c41d03c7ce0" id="r_a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0fcdaa10985d51cd8f533c41d03c7ce0">convert_utf16le_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-32 string.  <br /></td></tr>
<tr class="separator:a0fcdaa10985d51cd8f533c41d03c7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6297479226621edb24ffc30d642083d5" id="r_a6297479226621edb24ffc30d642083d5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a6297479226621edb24ffc30d642083d5">convert_utf16be_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a6297479226621edb24ffc30d642083d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-32 string.  <br /></td></tr>
<tr class="separator:a6297479226621edb24ffc30d642083d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53d42cf1525497c67690667242b669d" id="r_ab53d42cf1525497c67690667242b669d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ab53d42cf1525497c67690667242b669d">convert_utf16le_to_utf32_with_errors</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ab53d42cf1525497c67690667242b669d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16LE string into UTF-32 string and stop on error.  <br /></td></tr>
<tr class="separator:ab53d42cf1525497c67690667242b669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f306f07f9b0c88646629efc7672bfd" id="r_a78f306f07f9b0c88646629efc7672bfd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a78f306f07f9b0c88646629efc7672bfd">convert_utf16be_to_utf32_with_errors</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a78f306f07f9b0c88646629efc7672bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-16BE string into UTF-32 string and stop on error.  <br /></td></tr>
<tr class="separator:a78f306f07f9b0c88646629efc7672bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd5db8c4f3f4b6055497138f8cec860" id="r_a2bd5db8c4f3f4b6055497138f8cec860"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2bd5db8c4f3f4b6055497138f8cec860">convert_valid_utf16le_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a2bd5db8c4f3f4b6055497138f8cec860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-32 string.  <br /></td></tr>
<tr class="separator:a2bd5db8c4f3f4b6055497138f8cec860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e91ad7be0d09f713283d33105a4939" id="r_a15e91ad7be0d09f713283d33105a4939"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a15e91ad7be0d09f713283d33105a4939">convert_valid_utf16be_to_utf32</a> (const char16_t *input, size_t length, char32_t *utf32_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a15e91ad7be0d09f713283d33105a4939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-16LE string into UTF-32BE string.  <br /></td></tr>
<tr class="separator:a15e91ad7be0d09f713283d33105a4939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446248e71fc872b071d25a27673139f5" id="r_a446248e71fc872b071d25a27673139f5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a446248e71fc872b071d25a27673139f5">utf8_length_from_utf16le</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a446248e71fc872b071d25a27673139f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16LE string would require in UTF-8 format.  <br /></td></tr>
<tr class="separator:a446248e71fc872b071d25a27673139f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce2ef1ff8ab5ffd3999d545f703a2fd" id="r_abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#abce2ef1ff8ab5ffd3999d545f703a2fd">utf8_length_from_utf16be</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16BE string would require in UTF-8 format.  <br /></td></tr>
<tr class="separator:abce2ef1ff8ab5ffd3999d545f703a2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c1ec7808c2572670b540cd3ccce6b1" id="r_a66c1ec7808c2572670b540cd3ccce6b1"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a66c1ec7808c2572670b540cd3ccce6b1">convert_utf32_to_latin1</a> (const char32_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a66c1ec7808c2572670b540cd3ccce6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into Latin1 string.  <br /></td></tr>
<tr class="separator:a66c1ec7808c2572670b540cd3ccce6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d067614ecf86f2e7a6dfa2158567677" id="r_a2d067614ecf86f2e7a6dfa2158567677"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2d067614ecf86f2e7a6dfa2158567677">convert_utf32_to_latin1_with_errors</a> (const char32_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a2d067614ecf86f2e7a6dfa2158567677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into Latin1 string and stop on error.  <br /></td></tr>
<tr class="separator:a2d067614ecf86f2e7a6dfa2158567677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b1ec570f19982c826e2b04b501a1ac" id="r_a00b1ec570f19982c826e2b04b501a1ac"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a00b1ec570f19982c826e2b04b501a1ac">convert_valid_utf32_to_latin1</a> (const char32_t *input, size_t length, char *latin1_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a00b1ec570f19982c826e2b04b501a1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into Latin1 string.  <br /></td></tr>
<tr class="separator:a00b1ec570f19982c826e2b04b501a1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba1394d1cb70ff61ff9e10fec2b4ae" id="r_ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ac5ba1394d1cb70ff61ff9e10fec2b4ae">convert_utf32_to_utf8</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-8 string.  <br /></td></tr>
<tr class="separator:ac5ba1394d1cb70ff61ff9e10fec2b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad868e852d46a46b631524f2a4bb5f31d" id="r_ad868e852d46a46b631524f2a4bb5f31d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad868e852d46a46b631524f2a4bb5f31d">convert_utf32_to_utf8_with_errors</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:ad868e852d46a46b631524f2a4bb5f31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-8 string and stop on error.  <br /></td></tr>
<tr class="separator:ad868e852d46a46b631524f2a4bb5f31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d859ac6b4327e3155f1accef2f42c23" id="r_a5d859ac6b4327e3155f1accef2f42c23"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5d859ac6b4327e3155f1accef2f42c23">convert_valid_utf32_to_utf8</a> (const char32_t *input, size_t length, char *utf8_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a5d859ac6b4327e3155f1accef2f42c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-8 string.  <br /></td></tr>
<tr class="separator:a5d859ac6b4327e3155f1accef2f42c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5253692b2a0e1f15881b1fa393a2f42" id="r_af5253692b2a0e1f15881b1fa393a2f42"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#af5253692b2a0e1f15881b1fa393a2f42">utf16_length_from_latin1</a> (size_t length) const noexcept</td></tr>
<tr class="memdesc:af5253692b2a0e1f15881b1fa393a2f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that this UTF-16 string would require in Latin1 format.  <br /></td></tr>
<tr class="separator:af5253692b2a0e1f15881b1fa393a2f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342d098f7c92e8344944dfa947daa66d" id="r_a342d098f7c92e8344944dfa947daa66d"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a342d098f7c92e8344944dfa947daa66d">convert_utf32_to_utf16le</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a342d098f7c92e8344944dfa947daa66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16LE string.  <br /></td></tr>
<tr class="separator:a342d098f7c92e8344944dfa947daa66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f90a3a4b12a2e361618fb3e9e4b5cbd" id="r_a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7f90a3a4b12a2e361618fb3e9e4b5cbd">convert_utf32_to_utf16be</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16BE string.  <br /></td></tr>
<tr class="separator:a7f90a3a4b12a2e361618fb3e9e4b5cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af760d6a771de56c57588241cb01b597f" id="r_af760d6a771de56c57588241cb01b597f"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#af760d6a771de56c57588241cb01b597f">convert_utf32_to_utf16le_with_errors</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:af760d6a771de56c57588241cb01b597f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16LE string and stop on error.  <br /></td></tr>
<tr class="separator:af760d6a771de56c57588241cb01b597f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eed63c72cb1a7736ecb96f149d0ae6f" id="r_a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3eed63c72cb1a7736ecb96f149d0ae6f">convert_utf32_to_utf16be_with_errors</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert possibly broken UTF-32 string into UTF-16BE string and stop on error.  <br /></td></tr>
<tr class="separator:a3eed63c72cb1a7736ecb96f149d0ae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8ccb48c01e7f93480e9bdd7fb3beee" id="r_a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a9f8ccb48c01e7f93480e9bdd7fb3beee">convert_valid_utf32_to_utf16le</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-16LE string.  <br /></td></tr>
<tr class="separator:a9f8ccb48c01e7f93480e9bdd7fb3beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38557c96a34c9cc87f7294aca0538582" id="r_a38557c96a34c9cc87f7294aca0538582"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a38557c96a34c9cc87f7294aca0538582">convert_valid_utf32_to_utf16be</a> (const char32_t *input, size_t length, char16_t *utf16_buffer) const noexcept=0</td></tr>
<tr class="memdesc:a38557c96a34c9cc87f7294aca0538582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert valid UTF-32 string into UTF-16BE string.  <br /></td></tr>
<tr class="separator:a38557c96a34c9cc87f7294aca0538582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a342c5088a3b2887485836daa92628a" id="r_a8a342c5088a3b2887485836daa92628a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a8a342c5088a3b2887485836daa92628a">change_endianness_utf16</a> (const char16_t *input, size_t length, char16_t *output) const noexcept=0</td></tr>
<tr class="memdesc:a8a342c5088a3b2887485836daa92628a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the endianness of the input.  <br /></td></tr>
<tr class="separator:a8a342c5088a3b2887485836daa92628a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff358bb1f0b909cd1e9a6227656ee5d7" id="r_aff358bb1f0b909cd1e9a6227656ee5d7"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#aff358bb1f0b909cd1e9a6227656ee5d7">utf8_length_from_latin1</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:aff358bb1f0b909cd1e9a6227656ee5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that this Latin1 string would require in UTF-8 format.  <br /></td></tr>
<tr class="separator:aff358bb1f0b909cd1e9a6227656ee5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f39ff7d49c8864a9035c626825edad0" id="r_a2f39ff7d49c8864a9035c626825edad0"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2f39ff7d49c8864a9035c626825edad0">utf8_length_from_utf32</a> (const char32_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a2f39ff7d49c8864a9035c626825edad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-32 string would require in UTF-8 format.  <br /></td></tr>
<tr class="separator:a2f39ff7d49c8864a9035c626825edad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f951db4813c86b3eb8ea77ad7d2e144" id="r_a2f951db4813c86b3eb8ea77ad7d2e144"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2f951db4813c86b3eb8ea77ad7d2e144">latin1_length_from_utf32</a> (size_t length) const noexcept</td></tr>
<tr class="memdesc:a2f951db4813c86b3eb8ea77ad7d2e144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-32 string would require in Latin1 format.  <br /></td></tr>
<tr class="separator:a2f951db4813c86b3eb8ea77ad7d2e144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc04b416c87dfa742056ce5bd8033dc" id="r_a2cc04b416c87dfa742056ce5bd8033dc"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2cc04b416c87dfa742056ce5bd8033dc">latin1_length_from_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a2cc04b416c87dfa742056ce5bd8033dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-8 string would require in Latin1 format.  <br /></td></tr>
<tr class="separator:a2cc04b416c87dfa742056ce5bd8033dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099704e55511390542f01b57957e9d36" id="r_a099704e55511390542f01b57957e9d36"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a099704e55511390542f01b57957e9d36">latin1_length_from_utf16</a> (size_t length) const noexcept</td></tr>
<tr class="memdesc:a099704e55511390542f01b57957e9d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16LE/BE string would require in Latin1 format.  <br /></td></tr>
<tr class="separator:a099704e55511390542f01b57957e9d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3761299ce52ee8b2b480fcadc50b45a5" id="r_a3761299ce52ee8b2b480fcadc50b45a5"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a3761299ce52ee8b2b480fcadc50b45a5">utf16_length_from_utf32</a> (const char32_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a3761299ce52ee8b2b480fcadc50b45a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of two-byte code units that this UTF-32 string would require in UTF-16 format.  <br /></td></tr>
<tr class="separator:a3761299ce52ee8b2b480fcadc50b45a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9eb578e05cda0e4cb47d91208dbda9" id="r_a5e9eb578e05cda0e4cb47d91208dbda9"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5e9eb578e05cda0e4cb47d91208dbda9">utf32_length_from_latin1</a> (size_t length) const noexcept</td></tr>
<tr class="memdesc:a5e9eb578e05cda0e4cb47d91208dbda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes that this UTF-32 string would require in Latin1 format.  <br /></td></tr>
<tr class="separator:a5e9eb578e05cda0e4cb47d91208dbda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b225db7024f73fdcd6f84fb10ecdfe" id="r_a83b225db7024f73fdcd6f84fb10ecdfe"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a83b225db7024f73fdcd6f84fb10ecdfe">utf32_length_from_utf16le</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a83b225db7024f73fdcd6f84fb10ecdfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16LE string would require in UTF-32 format.  <br /></td></tr>
<tr class="separator:a83b225db7024f73fdcd6f84fb10ecdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5efd699e928178cb569ee2b9b0711" id="r_a0df5efd699e928178cb569ee2b9b0711"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0df5efd699e928178cb569ee2b9b0711">utf32_length_from_utf16be</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a0df5efd699e928178cb569ee2b9b0711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of bytes that this UTF-16BE string would require in UTF-32 format.  <br /></td></tr>
<tr class="separator:a0df5efd699e928178cb569ee2b9b0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612381e291d6a957707defcba3c5d4aa" id="r_a612381e291d6a957707defcba3c5d4aa"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a612381e291d6a957707defcba3c5d4aa">count_utf16le</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a612381e291d6a957707defcba3c5d4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <br /></td></tr>
<tr class="separator:a612381e291d6a957707defcba3c5d4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80712666d56ad7abb7cd8ea7862a4dd" id="r_ad80712666d56ad7abb7cd8ea7862a4dd"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad80712666d56ad7abb7cd8ea7862a4dd">count_utf16be</a> (const char16_t *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <br /></td></tr>
<tr class="separator:ad80712666d56ad7abb7cd8ea7862a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380f5ef4b282ef66210a84ebc84bce51" id="r_a380f5ef4b282ef66210a84ebc84bce51"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a380f5ef4b282ef66210a84ebc84bce51">count_utf8</a> (const char *input, size_t length) const noexcept=0</td></tr>
<tr class="memdesc:a380f5ef4b282ef66210a84ebc84bce51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of code points (characters) in the string assuming that it is valid.  <br /></td></tr>
<tr class="separator:a380f5ef4b282ef66210a84ebc84bce51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98579327df6c99c6bfab0394174363ee" id="r_a98579327df6c99c6bfab0394174363ee"><td class="memItemLeft" align="right" valign="top">simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a98579327df6c99c6bfab0394174363ee">maximal_binary_length_from_base64</a> (const char *input, size_t length) const noexcept</td></tr>
<tr class="memdesc:a98579327df6c99c6bfab0394174363ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the maximal binary length in bytes given the base64 input.  <br /></td></tr>
<tr class="separator:a98579327df6c99c6bfab0394174363ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3185b3c751048d78d91df45523deeef" id="r_ab3185b3c751048d78d91df45523deeef"><td class="memItemLeft" align="right" valign="top">simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ab3185b3c751048d78d91df45523deeef">maximal_binary_length_from_base64</a> (const char16_t *input, size_t length) const noexcept</td></tr>
<tr class="memdesc:ab3185b3c751048d78d91df45523deeef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the maximal binary length in bytes given the base64 input.  <br /></td></tr>
<tr class="separator:ab3185b3c751048d78d91df45523deeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a23d6e9c3c006b78fe5d5f158206139" id="r_a7a23d6e9c3c006b78fe5d5f158206139"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a7a23d6e9c3c006b78fe5d5f158206139">base64_to_binary</a> (const char *input, size_t length, char *output, base64_options options=base64_default, last_chunk_handling_options last_chunk_options=last_chunk_handling_options::loose) const noexcept=0</td></tr>
<tr class="memdesc:a7a23d6e9c3c006b78fe5d5f158206139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a base64 input to a binary output.  <br /></td></tr>
<tr class="separator:a7a23d6e9c3c006b78fe5d5f158206139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbe68f7c647d85ae9368dc7a2672479" id="r_a2bbe68f7c647d85ae9368dc7a2672479"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1full__result.html">full_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a2bbe68f7c647d85ae9368dc7a2672479">base64_to_binary_details</a> (const char *input, size_t length, char *output, base64_options options=base64_default, last_chunk_handling_options last_chunk_options=last_chunk_handling_options::loose) const noexcept=0</td></tr>
<tr class="memdesc:a2bbe68f7c647d85ae9368dc7a2672479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a base64 input to a binary output while returning more details than base64_to_binary.  <br /></td></tr>
<tr class="separator:a2bbe68f7c647d85ae9368dc7a2672479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe53ca34467a8421415162dff690d3b" id="r_acbe53ca34467a8421415162dff690d3b"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#acbe53ca34467a8421415162dff690d3b">base64_to_binary</a> (const char16_t *input, size_t length, char *output, base64_options options=base64_default, last_chunk_handling_options last_chunk_options=last_chunk_handling_options::loose) const noexcept=0</td></tr>
<tr class="memdesc:acbe53ca34467a8421415162dff690d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a base64 input to a binary output.  <br /></td></tr>
<tr class="separator:acbe53ca34467a8421415162dff690d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31993b9463fb0a4724353e928962ebbe" id="r_a31993b9463fb0a4724353e928962ebbe"><td class="memItemLeft" align="right" valign="top">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1full__result.html">full_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a31993b9463fb0a4724353e928962ebbe">base64_to_binary_details</a> (const char16_t *input, size_t length, char *output, base64_options options=base64_default, last_chunk_handling_options last_chunk_options=last_chunk_handling_options::loose) const noexcept=0</td></tr>
<tr class="memdesc:a31993b9463fb0a4724353e928962ebbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a base64 input to a binary output while returning more details than base64_to_binary.  <br /></td></tr>
<tr class="separator:a31993b9463fb0a4724353e928962ebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29569bd4700b3e7bedce1d0c5eec236" id="r_ad29569bd4700b3e7bedce1d0c5eec236"><td class="memItemLeft" align="right" valign="top">simdutf_warn_unused size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#ad29569bd4700b3e7bedce1d0c5eec236">base64_length_from_binary</a> (size_t length, base64_options options=base64_default) const noexcept</td></tr>
<tr class="memdesc:ad29569bd4700b3e7bedce1d0c5eec236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the base64 length in bytes given the length of a binary input.  <br /></td></tr>
<tr class="separator:ad29569bd4700b3e7bedce1d0c5eec236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5823f6a86315f4404a4f437977abf9df" id="r_a5823f6a86315f4404a4f437977abf9df"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a5823f6a86315f4404a4f437977abf9df">binary_to_base64</a> (const char *input, size_t length, char *output, base64_options options=base64_default) const noexcept=0</td></tr>
<tr class="memdesc:a5823f6a86315f4404a4f437977abf9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a binary input to a base64 output.  <br /></td></tr>
<tr class="separator:a5823f6a86315f4404a4f437977abf9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0383b9c8c879508752e083a34b6bae5d" id="r_a0383b9c8c879508752e083a34b6bae5d"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsimdutf_1_1implementation.html#a0383b9c8c879508752e083a34b6bae5d">find</a> (const char *start, const char *end, char character) const noexcept=0</td></tr>
<tr class="memdesc:a0383b9c8c879508752e083a34b6bae5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first occurrence of a character in a string.  <br /></td></tr>
<tr class="separator:a0383b9c8c879508752e083a34b6bae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d9730cac8457a84faa1f62ba347ed7" id="r_a02d9730cac8457a84faa1f62ba347ed7"><td class="memItemLeft" align="right" valign="top"><a id="a02d9730cac8457a84faa1f62ba347ed7" name="a02d9730cac8457a84faa1f62ba347ed7"></a>
virtual const char16_t *&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const char16_t *start, const char16_t *end, char16_t character) const noexcept=0</td></tr>
<tr class="separator:a02d9730cac8457a84faa1f62ba347ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of simdutf for a particular CPU architecture. </p>
<p>Also used to maintain the currently active implementation. The active implementation is automatically initialized on first use to the most advanced implementation supported by the host. </p>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l03470">3470</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="afd306a0bc3e221964af3f31a64784b12" name="afd306a0bc3e221964af3f31a64784b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd306a0bc3e221964af3f31a64784b12">&#9670;&#160;</a></span>autodetect_encoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual encoding_type simdutf::implementation::autodetect_encoding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will try to detect the encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to identify </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding type detected </dd></dl>

</div>
</div>
<a id="ad29569bd4700b3e7bedce1d0c5eec236" name="ad29569bd4700b3e7bedce1d0c5eec236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29569bd4700b3e7bedce1d0c5eec236">&#9670;&#160;</a></span>base64_length_from_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdutf_warn_unused size_t simdutf::implementation::base64_length_from_binary </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">base64_options&#160;</td>
          <td class="paramname"><em>options</em> = <code>base64_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the base64 length in bytes given the length of a binary input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the input in bytes @parem options the base64 options to use, can be base64_default or base64_url, is base64_default by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of base64 bytes </dd></dl>

</div>
</div>
<a id="a7a23d6e9c3c006b78fe5d5f158206139" name="a7a23d6e9c3c006b78fe5d5f158206139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a23d6e9c3c006b78fe5d5f158206139">&#9670;&#160;</a></span>base64_to_binary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::base64_to_binary </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">base64_options&#160;</td>
          <td class="paramname"><em>options</em> = <code>base64_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">last_chunk_handling_options&#160;</td>
          <td class="paramname"><em>last_chunk_options</em> = <code>last_chunk_handling_options::loose</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a base64 input to a binary output. </p>
<p>This function follows the WHATWG forgiving-base64 format, which means that it will ignore any ASCII spaces in the input. You may provide a padded input (with one or two equal signs at the end) or an unpadded input (without any equal signs at the end).</p>
<p>See <a href="https://infra.spec.whatwg.org/#forgiving-base64-decode">https://infra.spec.whatwg.org/#forgiving-base64-decode</a></p>
<p>This function will fail in case of invalid input. When last_chunk_options = loose, there are two possible reasons for failure: the input contains a number of base64 characters that when divided by 4, leaves a single remainder character (BASE64_INPUT_REMAINDER), or the input contains a character that is not a valid base64 character (INVALID_BASE64_CHARACTER).</p>
<p>You should call this function with a buffer that is at least maximal_binary_length_from_base64(input, length) bytes long. If you fail to provide that much space, the function may cause a buffer overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the base64 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to a buffer that can hold the conversion result (should be at least maximal_binary_length_from_base64(input, length) bytes long). </td></tr>
    <tr><td class="paramname">options</td><td>the base64 options to use, can be base64_default or base64_url, is base64_default by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in bytes) if any, or the number of bytes written if successful. </dd></dl>

</div>
</div>
<a id="acbe53ca34467a8421415162dff690d3b" name="acbe53ca34467a8421415162dff690d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe53ca34467a8421415162dff690d3b">&#9670;&#160;</a></span>base64_to_binary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::base64_to_binary </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">base64_options&#160;</td>
          <td class="paramname"><em>options</em> = <code>base64_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">last_chunk_handling_options&#160;</td>
          <td class="paramname"><em>last_chunk_options</em> = <code>last_chunk_handling_options::loose</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a base64 input to a binary output. </p>
<p>This function follows the WHATWG forgiving-base64 format, which means that it will ignore any ASCII spaces in the input. You may provide a padded input (with one or two equal signs at the end) or an unpadded input (without any equal signs at the end).</p>
<p>See <a href="https://infra.spec.whatwg.org/#forgiving-base64-decode">https://infra.spec.whatwg.org/#forgiving-base64-decode</a></p>
<p>This function will fail in case of invalid input. When last_chunk_options = loose, there are two possible reasons for failure: the input contains a number of base64 characters that when divided by 4, leaves a single remainder character (BASE64_INPUT_REMAINDER), or the input contains a character that is not a valid base64 character (INVALID_BASE64_CHARACTER).</p>
<p>You should call this function with a buffer that is at least maximal_binary_length_from_base64(input, length) bytes long. If you fail to provide that much space, the function may cause a buffer overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the base64 string to process, in ASCII stored as 16-bit units </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 16-bit units </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to a buffer that can hold the conversion result (should be at least maximal_binary_length_from_base64(input, length) bytes long). </td></tr>
    <tr><td class="paramname">options</td><td>the base64 options to use, can be base64_default or base64_url, is base64_default by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and position of the INVALID_BASE64_CHARACTER error (in the input in units) if any, or the number of bytes written if successful. </dd></dl>

</div>
</div>
<a id="a2bbe68f7c647d85ae9368dc7a2672479" name="a2bbe68f7c647d85ae9368dc7a2672479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbe68f7c647d85ae9368dc7a2672479">&#9670;&#160;</a></span>base64_to_binary_details() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1full__result.html">full_result</a> simdutf::implementation::base64_to_binary_details </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">base64_options&#160;</td>
          <td class="paramname"><em>options</em> = <code>base64_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">last_chunk_handling_options&#160;</td>
          <td class="paramname"><em>last_chunk_options</em> = <code>last_chunk_handling_options::loose</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a base64 input to a binary output while returning more details than base64_to_binary. </p>
<p>This function follows the WHATWG forgiving-base64 format, which means that it will ignore any ASCII spaces in the input. You may provide a padded input (with one or two equal signs at the end) or an unpadded input (without any equal signs at the end).</p>
<p>See <a href="https://infra.spec.whatwg.org/#forgiving-base64-decode">https://infra.spec.whatwg.org/#forgiving-base64-decode</a></p>
<p>This function will fail in case of invalid input. When last_chunk_options = loose, there are two possible reasons for failure: the input contains a number of base64 characters that when divided by 4, leaves a single remainder character (BASE64_INPUT_REMAINDER), or the input contains a character that is not a valid base64 character (INVALID_BASE64_CHARACTER).</p>
<p>You should call this function with a buffer that is at least maximal_binary_length_from_base64(input, length) bytes long. If you fail to provide that much space, the function may cause a buffer overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the base64 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to a buffer that can hold the conversion result (should be at least maximal_binary_length_from_base64(input, length) bytes long). </td></tr>
    <tr><td class="paramname">options</td><td>the base64 options to use, can be base64_default or base64_url, is base64_default by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structsimdutf_1_1full__result.html">full_result</a> pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the three fields error, input_count and output_count). </dd></dl>

</div>
</div>
<a id="a31993b9463fb0a4724353e928962ebbe" name="a31993b9463fb0a4724353e928962ebbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31993b9463fb0a4724353e928962ebbe">&#9670;&#160;</a></span>base64_to_binary_details() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1full__result.html">full_result</a> simdutf::implementation::base64_to_binary_details </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">base64_options&#160;</td>
          <td class="paramname"><em>options</em> = <code>base64_default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">last_chunk_handling_options&#160;</td>
          <td class="paramname"><em>last_chunk_options</em> = <code>last_chunk_handling_options::loose</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a base64 input to a binary output while returning more details than base64_to_binary. </p>
<p>This function follows the WHATWG forgiving-base64 format, which means that it will ignore any ASCII spaces in the input. You may provide a padded input (with one or two equal signs at the end) or an unpadded input (without any equal signs at the end).</p>
<p>See <a href="https://infra.spec.whatwg.org/#forgiving-base64-decode">https://infra.spec.whatwg.org/#forgiving-base64-decode</a></p>
<p>This function will fail in case of invalid input. When last_chunk_options = loose, there are two possible reasons for failure: the input contains a number of base64 characters that when divided by 4, leaves a single remainder character (BASE64_INPUT_REMAINDER), or the input contains a character that is not a valid base64 character (INVALID_BASE64_CHARACTER).</p>
<p>You should call this function with a buffer that is at least maximal_binary_length_from_base64(input, length) bytes long. If you fail to provide that much space, the function may cause a buffer overflow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the base64 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to a buffer that can hold the conversion result (should be at least maximal_binary_length_from_base64(input, length) bytes long). </td></tr>
    <tr><td class="paramname">options</td><td>the base64 options to use, can be base64_default or base64_url, is base64_default by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structsimdutf_1_1full__result.html">full_result</a> pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the three fields error, input_count and output_count). </dd></dl>

</div>
</div>
<a id="a5823f6a86315f4404a4f437977abf9df" name="a5823f6a86315f4404a4f437977abf9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5823f6a86315f4404a4f437977abf9df">&#9670;&#160;</a></span>binary_to_base64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t simdutf::implementation::binary_to_base64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">base64_options&#160;</td>
          <td class="paramname"><em>options</em> = <code>base64_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a binary input to a base64 output. </p>
<p>The default option (simdutf::base64_default) uses the characters <code>+</code> and <code>/</code> as part of its alphabet. Further, it adds padding (<code>=</code>) at the end of the output to ensure that the output length is a multiple of four.</p>
<p>The URL option (simdutf::base64_url) uses the characters <code>-</code> and <code>_</code> as part of its alphabet. No padding is added at the end of the output.</p>
<p>This function always succeeds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the binary to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the input in bytes </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to a buffer that can hold the conversion result (should be at least base64_length_from_binary(length) bytes long) </td></tr>
    <tr><td class="paramname">options</td><td>the base64 options to use, can be base64_default or base64_url, is base64_default by default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written bytes, will be equal to base64_length_from_binary(length, options) </dd></dl>

</div>
</div>
<a id="a8a342c5088a3b2887485836daa92628a" name="a8a342c5088a3b2887485836daa92628a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a342c5088a3b2887485836daa92628a">&#9670;&#160;</a></span>change_endianness_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void simdutf::implementation::change_endianness_utf16 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the endianness of the input. </p>
<p>Can be used to go from UTF-16LE to UTF-16BE or from UTF-16BE to UTF-16LE.</p>
<p>This function does not validate the input.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">output</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f498ad9236b916e5e4859109d1df0bb" name="a2f498ad9236b916e5e4859109d1df0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f498ad9236b916e5e4859109d1df0bb">&#9670;&#160;</a></span>convert_latin1_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Latin1 string into UTF-16BE string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a2315da3daf654f4a7132b1751394b374" name="a2315da3daf654f4a7132b1751394b374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2315da3daf654f4a7132b1751394b374">&#9670;&#160;</a></span>convert_latin1_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly Latin1 string into UTF-16LE string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a5bb5a0db793a6e332711c24d9cbc14fd" name="a5bb5a0db793a6e332711c24d9cbc14fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb5a0db793a6e332711c24d9cbc14fd">&#9670;&#160;</a></span>convert_latin1_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Latin1 string into UTF-32 string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="af79deb79661a71f145b7bc6786fe4223" name="af79deb79661a71f145b7bc6786fe4223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79deb79661a71f145b7bc6786fe4223">&#9670;&#160;</a></span>convert_latin1_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_latin1_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Latin1 string into UTF-8 string. </p>
<p>This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf8_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="ac941440407fed1518a179f1d0396720c" name="ac941440407fed1518a179f1d0396720c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac941440407fed1518a179f1d0396720c">&#9670;&#160;</a></span>convert_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16BE string or if it cannot be represented as Latin1 </dd></dl>

</div>
</div>
<a id="a29a8022ac1760f081d389cb00a4dac80" name="a29a8022ac1760f081d389cb00a4dac80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a8022ac1760f081d389cb00a4dac80">&#9670;&#160;</a></span>convert_utf16be_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into Latin1 string. </p>
<p>If the string cannot be represented as Latin1, an error is returned.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a6297479226621edb24ffc30d642083d5" name="a6297479226621edb24ffc30d642083d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6297479226621edb24ffc30d642083d5">&#9670;&#160;</a></span>convert_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16BE string </dd></dl>

</div>
</div>
<a id="a78f306f07f9b0c88646629efc7672bfd" name="a78f306f07f9b0c88646629efc7672bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f306f07f9b0c88646629efc7672bfd">&#9670;&#160;</a></span>convert_utf16be_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a4694517e0f22276fea37d154e35648e4" name="a4694517e0f22276fea37d154e35648e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4694517e0f22276fea37d154e35648e4">&#9670;&#160;</a></span>convert_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16BE string </dd></dl>

</div>
</div>
<a id="a558db3f984286ccd44517a622f8cd676" name="a558db3f984286ccd44517a622f8cd676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558db3f984286ccd44517a622f8cd676">&#9670;&#160;</a></span>convert_utf16be_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16be_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16BE string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a75f16dc0f3bdd4457425898a17c51d45" name="a75f16dc0f3bdd4457425898a17c51d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f16dc0f3bdd4457425898a17c51d45">&#9670;&#160;</a></span>convert_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string or if it cannot be represented as Latin1 </dd></dl>

</div>
</div>
<a id="a4aa4c4b831e691e623552bbf9c60b801" name="a4aa4c4b831e691e623552bbf9c60b801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa4c4b831e691e623552bbf9c60b801">&#9670;&#160;</a></span>convert_utf16le_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into Latin1 string. </p>
<p>If the string cannot be represented as Latin1, an error is returned.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources. This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a0fcdaa10985d51cd8f533c41d03c7ce0" name="a0fcdaa10985d51cd8f533c41d03c7ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdaa10985d51cd8f533c41d03c7ce0">&#9670;&#160;</a></span>convert_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="ab53d42cf1525497c67690667242b669d" name="ab53d42cf1525497c67690667242b669d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53d42cf1525497c67690667242b669d">&#9670;&#160;</a></span>convert_utf16le_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="abca86864832acad7c1277e6675c73e58" name="abca86864832acad7c1277e6675c73e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca86864832acad7c1277e6675c73e58">&#9670;&#160;</a></span>convert_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-16LE string </dd></dl>

</div>
</div>
<a id="a77cb2f67aadb85bb3c64789f3d501d8b" name="a77cb2f67aadb85bb3c64789f3d501d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cb2f67aadb85bb3c64789f3d501d8b">&#9670;&#160;</a></span>convert_utf16le_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf16le_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-16LE string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a66c1ec7808c2572670b540cd3ccce6b1" name="a66c1ec7808c2572670b540cd3ccce6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c1ec7808c2572670b540cd3ccce6b1">&#9670;&#160;</a></span>convert_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into Latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a2d067614ecf86f2e7a6dfa2158567677" name="a2d067614ecf86f2e7a6dfa2158567677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d067614ecf86f2e7a6dfa2158567677">&#9670;&#160;</a></span>convert_utf32_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into Latin1 string and stop on error. </p>
<p>If the string cannot be represented as Latin1, an error is returned.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="a7f90a3a4b12a2e361618fb3e9e4b5cbd" name="a7f90a3a4b12a2e361618fb3e9e4b5cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f90a3a4b12a2e361618fb3e9e4b5cbd">&#9670;&#160;</a></span>convert_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16BE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="a3eed63c72cb1a7736ecb96f149d0ae6f" name="a3eed63c72cb1a7736ecb96f149d0ae6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eed63c72cb1a7736ecb96f149d0ae6f">&#9670;&#160;</a></span>convert_utf32_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16BE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="a342d098f7c92e8344944dfa947daa66d" name="a342d098f7c92e8344944dfa947daa66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342d098f7c92e8344944dfa947daa66d">&#9670;&#160;</a></span>convert_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16LE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="af760d6a771de56c57588241cb01b597f" name="af760d6a771de56c57588241cb01b597f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af760d6a771de56c57588241cb01b597f">&#9670;&#160;</a></span>convert_utf32_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-16LE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char16_t written if successful. </dd></dl>

</div>
</div>
<a id="ac5ba1394d1cb70ff61ff9e10fec2b4ae" name="ac5ba1394d1cb70ff61ff9e10fec2b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ba1394d1cb70ff61ff9e10fec2b4ae">&#9670;&#160;</a></span>convert_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-8 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if input is not a valid UTF-32 string </dd></dl>

</div>
</div>
<a id="ad868e852d46a46b631524f2a4bb5f31d" name="ad868e852d46a46b631524f2a4bb5f31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad868e852d46a46b631524f2a4bb5f31d">&#9670;&#160;</a></span>convert_utf32_to_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf32_to_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-32 string into UTF-8 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char written if successful. </dd></dl>

</div>
</div>
<a id="ac9c2c1418f08f84e36c22727879db307" name="ac9c2c1418f08f84e36c22727879db307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c2c1418f08f84e36c22727879db307">&#9670;&#160;</a></span>convert_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into latin1 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string or if it cannot be represented as Latin1 </dd></dl>

</div>
</div>
<a id="ae845d016f715c25475970c4dfcb58a8d" name="ae845d016f715c25475970c4dfcb58a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae845d016f715c25475970c4dfcb58a8d">&#9670;&#160;</a></span>convert_utf8_to_latin1_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_latin1_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into latin1 string with errors. </p>
<p>If the string cannot be represented as Latin1, an error code is returned.</p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a0eb08f6b1d102dd298f3d265615b21aa" name="a0eb08f6b1d102dd298f3d265615b21aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb08f6b1d102dd298f3d265615b21aa">&#9670;&#160;</a></span>convert_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16BE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="ae18e1b44673966d2f058524700d41db0" name="ae18e1b44673966d2f058524700d41db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18e1b44673966d2f058524700d41db0">&#9670;&#160;</a></span>convert_utf8_to_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16BE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a487615c5d6dc00183fdf6a904bd829dc" name="a487615c5d6dc00183fdf6a904bd829dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487615c5d6dc00183fdf6a904bd829dc">&#9670;&#160;</a></span>convert_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16LE string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a6091f1fbcaf897575af907ab8896d151" name="a6091f1fbcaf897575af907ab8896d151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6091f1fbcaf897575af907ab8896d151">&#9670;&#160;</a></span>convert_utf8_to_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-16LE string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="aab894ce236190e9cc71e0ce1602bbc60" name="aab894ce236190e9cc71e0ce1602bbc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab894ce236190e9cc71e0ce1602bbc60">&#9670;&#160;</a></span>convert_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-32 string. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a5c5166f22c16902452eec6a93ad7a926" name="a5c5166f22c16902452eec6a93ad7a926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5166f22c16902452eec6a93ad7a926">&#9670;&#160;</a></span>convert_utf8_to_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::convert_utf8_to_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert possibly broken UTF-8 string into UTF-32 string and stop on error. </p>
<p>During the conversion also validation of the input string is done. This function is suitable to work with inputs from untrusted sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of char32_t written if successful. </dd></dl>

</div>
</div>
<a id="a6896e27fd7fe773ba25bfaed081aafaa" name="a6896e27fd7fe773ba25bfaed081aafaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6896e27fd7fe773ba25bfaed081aafaa">&#9670;&#160;</a></span>convert_valid_utf16be_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16BE string into Latin1 string. </p>
<p>This function assumes that the input string is valid UTF16-BE and that it can be represented as Latin1. If you violate this assumption, the result is implementation defined and may include system-dependent behavior such as crashes.</p>
<p>This function is for expert users only and not part of our public API. Use convert_utf16be_to_latin1 instead.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a15e91ad7be0d09f713283d33105a4939" name="a15e91ad7be0d09f713283d33105a4939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e91ad7be0d09f713283d33105a4939">&#9670;&#160;</a></span>convert_valid_utf16be_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-32BE string. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a204aff56bf36d384694a5b5e73ddc579" name="a204aff56bf36d384694a5b5e73ddc579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204aff56bf36d384694a5b5e73ddc579">&#9670;&#160;</a></span>convert_valid_utf16be_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16be_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16BE string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-16BE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a65c8a9e58f4c111d52851e4fdbca0af1" name="a65c8a9e58f4c111d52851e4fdbca0af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c8a9e58f4c111d52851e4fdbca0af1">&#9670;&#160;</a></span>convert_valid_utf16le_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into Latin1 string. </p>
<p>This function assumes that the input string is valid UTF-L16LE and that it can be represented as Latin1. If you violate this assumption, the result is implementation defined and may include system-dependent behavior such as crashes.</p>
<p>This function is for expert users only and not part of our public API. Use convert_utf16le_to_latin1 instead.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a2bd5db8c4f3f4b6055497138f8cec860" name="a2bd5db8c4f3f4b6055497138f8cec860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd5db8c4f3f4b6055497138f8cec860">&#9670;&#160;</a></span>convert_valid_utf16le_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-32 string. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf32_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a3d5ab12b92ea57e2b88af5b19118833b" name="a3d5ab12b92ea57e2b88af5b19118833b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5ab12b92ea57e2b88af5b19118833b">&#9670;&#160;</a></span>convert_valid_utf16le_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf16le_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-16LE string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-16LE.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a00b1ec570f19982c826e2b04b501a1ac" name="a00b1ec570f19982c826e2b04b501a1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b1ec570f19982c826e2b04b501a1ac">&#9670;&#160;</a></span>convert_valid_utf32_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into Latin1 string. </p>
<p>This function assumes that the input string is valid UTF-32 and can be represented as Latin1. If you violate this assumption, the result is implementation defined and may include system-dependent behavior such as crashes.</p>
<p>This function is for expert users only and not part of our public API. Use convert_utf32_to_latin1 instead.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">latin1_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a38557c96a34c9cc87f7294aca0538582" name="a38557c96a34c9cc87f7294aca0538582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38557c96a34c9cc87f7294aca0538582">&#9670;&#160;</a></span>convert_valid_utf32_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-16BE string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a9f8ccb48c01e7f93480e9bdd7fb3beee" name="a9f8ccb48c01e7f93480e9bdd7fb3beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8ccb48c01e7f93480e9bdd7fb3beee">&#9670;&#160;</a></span>convert_valid_utf32_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-16LE string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a5d859ac6b4327e3155f1accef2f42c23" name="a5d859ac6b4327e3155f1accef2f42c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d859ac6b4327e3155f1accef2f42c23">&#9670;&#160;</a></span>convert_valid_utf32_to_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf32_to_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>utf8_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-32 string into UTF-8 string. </p>
<p>This function assumes that the input string is valid UTF-32.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
    <tr><td class="paramname">utf8_buffer</td><td>the pointer to a buffer that can hold the conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of written code units; 0 if conversion is not possible </dd></dl>

</div>
</div>
<a id="a903279159cb5f5e0e767cce6f1440889" name="a903279159cb5f5e0e767cce6f1440889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903279159cb5f5e0e767cce6f1440889">&#9670;&#160;</a></span>convert_valid_utf8_to_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>latin1_output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into latin1 string. </p>
<p>This function assumes that the input string is valid UTF-8 and that it can be represented as Latin1. If you violate this assumption, the result is implementation defined and may include system-dependent behavior such as crashes.</p>
<p>This function is for expert users only and not part of our public API. Use convert_utf8_to_latin1 instead.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">latin1_output</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char; 0 if the input was not valid UTF-8 string </dd></dl>

</div>
</div>
<a id="a8d655f7769c5e5039821d512c116dc56" name="a8d655f7769c5e5039821d512c116dc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d655f7769c5e5039821d512c116dc56">&#9670;&#160;</a></span>convert_valid_utf8_to_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-16BE string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a08870586c80a46861a25c715323402c1" name="a08870586c80a46861a25c715323402c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08870586c80a46861a25c715323402c1">&#9670;&#160;</a></span>convert_valid_utf8_to_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>utf16_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-16LE string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char16_t </dd></dl>

</div>
</div>
<a id="a7566c1718e91a6d36b0c47822b0154ad" name="a7566c1718e91a6d36b0c47822b0154ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7566c1718e91a6d36b0c47822b0154ad">&#9670;&#160;</a></span>convert_valid_utf8_to_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::convert_valid_utf8_to_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char32_t *&#160;</td>
          <td class="paramname"><em>utf32_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert valid UTF-8 string into UTF-32 string. </p>
<p>This function assumes that the input string is valid UTF-8.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
    <tr><td class="paramname">utf16_buffer</td><td>the pointer to buffer that can hold conversion result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of written char32_t </dd></dl>

</div>
</div>
<a id="ad80712666d56ad7abb7cd8ea7862a4dd" name="ad80712666d56ad7abb7cd8ea7862a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80712666d56ad7abb7cd8ea7862a4dd">&#9670;&#160;</a></span>count_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-16BE. It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a612381e291d6a957707defcba3c5d4aa" name="a612381e291d6a957707defcba3c5d4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612381e291d6a957707defcba3c5d4aa">&#9670;&#160;</a></span>count_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-16LE. It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="a380f5ef4b282ef66210a84ebc84bce51" name="a380f5ef4b282ef66210a84ebc84bce51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380f5ef4b282ef66210a84ebc84bce51">&#9670;&#160;</a></span>count_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::count_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of code points (characters) in the string assuming that it is valid. </p>
<p>This function assumes that the input string is valid UTF-8. It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of code points </dd></dl>

</div>
</div>
<a id="af48e75e8d6d25c3c3d66334a8849cbc7" name="af48e75e8d6d25c3c3d66334a8849cbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48e75e8d6d25c3c3d66334a8849cbc7">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string simdutf::implementation::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The description of this implementation. </p>
<pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt;
</pre><p> impl-&gt;<a class="el" href="classsimdutf_1_1implementation.html#af48e75e8d6d25c3c3d66334a8849cbc7" title="The description of this implementation.">description()</a> &lt;&lt; ")" &lt;&lt; endl;</p>
<dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l03492">3492</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="ad4a7dbe2fbc9d03da2542c07a88cdddb" name="ad4a7dbe2fbc9d03da2542c07a88cdddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a7dbe2fbc9d03da2542c07a88cdddb">&#9670;&#160;</a></span>detect_encodings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int simdutf::implementation::detect_encodings </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function will try to detect the possible encodings in one pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the string to identify </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the encoding type detected </dd></dl>

</div>
</div>
<a id="a0383b9c8c879508752e083a34b6bae5d" name="a0383b9c8c879508752e083a34b6bae5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0383b9c8c879508752e083a34b6bae5d">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * simdutf::implementation::find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the first occurrence of a character in a string. </p>
<p>If the character is not found, return a pointer to the end of the string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the start of the string </td></tr>
    <tr><td class="paramname">end</td><td>the end of the string </td></tr>
    <tr><td class="paramname">character</td><td>the character to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first occurrence of the character in the string, or a pointer to the end of the string if the character is not found. </dd></dl>

</div>
</div>
<a id="a099704e55511390542f01b57957e9d36" name="a099704e55511390542f01b57957e9d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099704e55511390542f01b57957e9d36">&#9670;&#160;</a></span>latin1_length_from_utf16()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::latin1_length_from_utf16 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16LE/BE string would require in Latin1 format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as Latin1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l04836">4836</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="a2f951db4813c86b3eb8ea77ad7d2e144" name="a2f951db4813c86b3eb8ea77ad7d2e144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f951db4813c86b3eb8ea77ad7d2e144">&#9670;&#160;</a></span>latin1_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::latin1_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-32 string would require in Latin1 format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-32 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as Latin1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l04798">4798</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="a2cc04b416c87dfa742056ce5bd8033dc" name="a2cc04b416c87dfa742056ce5bd8033dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc04b416c87dfa742056ce5bd8033dc">&#9670;&#160;</a></span>latin1_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::latin1_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-8 string would require in Latin1 format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-8 string as Latin1 </dd></dl>

</div>
</div>
<a id="a98579327df6c99c6bfab0394174363ee" name="a98579327df6c99c6bfab0394174363ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98579327df6c99c6bfab0394174363ee">&#9670;&#160;</a></span>maximal_binary_length_from_base64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdutf_warn_unused size_t simdutf::implementation::maximal_binary_length_from_base64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the maximal binary length in bytes given the base64 input. </p>
<p>In general, if the input contains ASCII spaces, the result will be less than the maximum length. It is acceptable to pass invalid base64 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the base64 input to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the base64 input in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximal number of binary bytes </dd></dl>

</div>
</div>
<a id="ab3185b3c751048d78d91df45523deeef" name="ab3185b3c751048d78d91df45523deeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3185b3c751048d78d91df45523deeef">&#9670;&#160;</a></span>maximal_binary_length_from_base64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">simdutf_warn_unused size_t simdutf::implementation::maximal_binary_length_from_base64 </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide the maximal binary length in bytes given the base64 input. </p>
<p>In general, if the input contains ASCII spaces, the result will be less than the maximum length. It is acceptable to pass invalid base64 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the base64 input to process, in ASCII stored as 16-bit units </td></tr>
    <tr><td class="paramname">length</td><td>the length of the base64 input in 16-bit units </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximal number of binary bytes </dd></dl>

</div>
</div>
<a id="aa5bf5083338ae14df38af6661041e53b" name="aa5bf5083338ae14df38af6661041e53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bf5083338ae14df38af6661041e53b">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string simdutf::implementation::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of this implementation. </p>
<pre class="fragment">const implementation *impl = simdutf::active_implementation;
cout &lt;&lt; "simdutf is optimized for " &lt;&lt; impl-&gt;name() &lt;&lt; "(" &lt;&lt;
</pre><p> impl-&gt;<a class="el" href="classsimdutf_1_1implementation.html#af48e75e8d6d25c3c3d66334a8849cbc7" title="The description of this implementation.">description()</a> &lt;&lt; ")" &lt;&lt; endl;</p>
<dl class="section return"><dt>Returns</dt><dd>the name of the implementation, e.g. "haswell", "westmere", "arm64" </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l03481">3481</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="a6cd8f7d8787c76e690ed9c4151abb7a9" name="a6cd8f7d8787c76e690ed9c4151abb7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd8f7d8787c76e690ed9c4151abb7a9">&#9670;&#160;</a></span>supported_by_runtime_system()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool simdutf::implementation::supported_by_runtime_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The instruction sets this implementation is compiled against and the current CPU match. </p>
<p>This function may poll the current CPU/system and should therefore not be called too often if performance is a concern.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the implementation can be safely used on the current system (determined at runtime) </dd></dl>

</div>
</div>
<a id="adaf5488b9e07462f004b8aa819b85e73" name="adaf5488b9e07462f004b8aa819b85e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf5488b9e07462f004b8aa819b85e73">&#9670;&#160;</a></span>to_well_formed_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void simdutf::implementation::to_well_formed_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the UTF-16BE string while replacing mismatched surrogates with the Unicode replacement character U+FFFD. </p>
<p>We allow the input and output to be the same buffer so that the correction is done in-place.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to correct. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
    <tr><td class="paramname">output</td><td>the output buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d8b3a891225e204cb9e98fbea8a7dab" name="a3d8b3a891225e204cb9e98fbea8a7dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8b3a891225e204cb9e98fbea8a7dab">&#9670;&#160;</a></span>to_well_formed_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void simdutf::implementation::to_well_formed_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char16_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the UTF-16LE string while replacing mismatched surrogates with the Unicode replacement character U+FFFD. </p>
<p>We allow the input and output to be the same buffer so that the correction is done in-place.</p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to correct. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
    <tr><td class="paramname">output</td><td>the output buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5253692b2a0e1f15881b1fa393a2f42" name="af5253692b2a0e1f15881b1fa393a2f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5253692b2a0e1f15881b1fa393a2f42">&#9670;&#160;</a></span>utf16_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that this UTF-16 string would require in Latin1 format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16 string as Latin1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l04610">4610</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="a3761299ce52ee8b2b480fcadc50b45a5" name="a3761299ce52ee8b2b480fcadc50b45a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3761299ce52ee8b2b480fcadc50b45a5">&#9670;&#160;</a></span>utf16_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of two-byte code units that this UTF-32 string would require in UTF-16 format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-32 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-16 </dd></dl>

</div>
</div>
<a id="ae01141d4bf774c95e771924caa11efb1" name="ae01141d4bf774c95e771924caa11efb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01141d4bf774c95e771924caa11efb1">&#9670;&#160;</a></span>utf16_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf16_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of 2-byte code units that this UTF-8 string would require in UTF-16LE format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char16_t code units required to encode the UTF-8 string as UTF-16LE </dd></dl>

</div>
</div>
<a id="a5e9eb578e05cda0e4cb47d91208dbda9" name="a5e9eb578e05cda0e4cb47d91208dbda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9eb578e05cda0e4cb47d91208dbda9">&#9670;&#160;</a></span>utf32_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf32_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that this UTF-32 string would require in Latin1 format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as Latin1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="implementation_8h_source.html#l04869">4869</a> of file <a class="el" href="implementation_8h_source.html">implementation.h</a>.</p>

</div>
</div>
<a id="a0df5efd699e928178cb569ee2b9b0711" name="a0df5efd699e928178cb569ee2b9b0711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df5efd699e928178cb569ee2b9b0711">&#9670;&#160;</a></span>utf32_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf32_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16BE string would require in UTF-32 format. </p>
<p>This function is equivalent to count_utf16be.</p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16BE string as UTF-32 </dd></dl>

</div>
</div>
<a id="a83b225db7024f73fdcd6f84fb10ecdfe" name="a83b225db7024f73fdcd6f84fb10ecdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b225db7024f73fdcd6f84fb10ecdfe">&#9670;&#160;</a></span>utf32_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf32_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16LE string would require in UTF-32 format. </p>
<p>This function is equivalent to count_utf16le.</p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-32 </dd></dl>

</div>
</div>
<a id="a39bc047dd50ede9cd33cb7e825eb5b56" name="a39bc047dd50ede9cd33cb7e825eb5b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bc047dd50ede9cd33cb7e825eb5b56">&#9670;&#160;</a></span>utf32_length_from_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf32_length_from_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of 4-byte code units that this UTF-8 string would require in UTF-32 format. </p>
<p>This function is equivalent to count_utf8. It is acceptable to pass invalid UTF-8 strings but in such cases the result is implementation defined.</p>
<p>This function does not validate the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-8 string to process </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of char32_t code units required to encode the UTF-8 string as UTF-32 </dd></dl>

</div>
</div>
<a id="aff358bb1f0b909cd1e9a6227656ee5d7" name="aff358bb1f0b909cd1e9a6227656ee5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff358bb1f0b909cd1e9a6227656ee5d7">&#9670;&#160;</a></span>utf8_length_from_latin1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_latin1 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes that this Latin1 string would require in UTF-8 format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the Latin1 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the Latin1 string as UTF-8 </dd></dl>

</div>
</div>
<a id="abce2ef1ff8ab5ffd3999d545f703a2fd" name="abce2ef1ff8ab5ffd3999d545f703a2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce2ef1ff8ab5ffd3999d545f703a2fd">&#9670;&#160;</a></span>utf8_length_from_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16BE string would require in UTF-8 format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16BE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16BE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a446248e71fc872b071d25a27673139f5" name="a446248e71fc872b071d25a27673139f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446248e71fc872b071d25a27673139f5">&#9670;&#160;</a></span>utf8_length_from_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-16LE string would require in UTF-8 format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-16 strings but in such cases the result is implementation defined.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-16LE string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 2-byte code units (char16_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-16LE string as UTF-8 </dd></dl>

</div>
</div>
<a id="a2f39ff7d49c8864a9035c626825edad0" name="a2f39ff7d49c8864a9035c626825edad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f39ff7d49c8864a9035c626825edad0">&#9670;&#160;</a></span>utf8_length_from_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused size_t simdutf::implementation::utf8_length_from_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the number of bytes that this UTF-32 string would require in UTF-8 format. </p>
<p>This function does not validate the input. It is acceptable to pass invalid UTF-32 strings but in such cases the result is implementation defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the UTF-32 string to convert </td></tr>
    <tr><td class="paramname">length</td><td>the length of the string in 4-byte code units (char32_t) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes required to encode the UTF-32 string as UTF-8 </dd></dl>

</div>
</div>
<a id="adde94939db547675113aa71ec979d2ce" name="adde94939db547675113aa71ec979d2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde94939db547675113aa71ec979d2ce">&#9670;&#160;</a></span>validate_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_ascii </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the ASCII string. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid ASCII. </dd></dl>

</div>
</div>
<a id="aa73e0b4e751f59a6f67c0bde3e503e23" name="aa73e0b4e751f59a6f67c0bde3e503e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73e0b4e751f59a6f67c0bde3e503e23">&#9670;&#160;</a></span>validate_ascii_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_ascii_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the ASCII string and stop on error. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the ASCII string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a27a221cf4c4d195d110387d10bbd4b33" name="a27a221cf4c4d195d110387d10bbd4b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a221cf4c4d195d110387d10bbd4b33">&#9670;&#160;</a></span>validate_utf16be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf16be </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16BE string. </p>
<p>This function may be best when you expect the input to be almost always valid. Otherwise, consider using validate_utf16be_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16BE. </dd></dl>

</div>
</div>
<a id="a7632c87e825c7f268cbb787612e940bf" name="a7632c87e825c7f268cbb787612e940bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7632c87e825c7f268cbb787612e940bf">&#9670;&#160;</a></span>validate_utf16be_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf16be_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16BE string and stop on error. </p>
<p>It might be faster than validate_utf16be when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16BE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="a6047ac139bd2e8f6808a5bbd4b687629" name="a6047ac139bd2e8f6808a5bbd4b687629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6047ac139bd2e8f6808a5bbd4b687629">&#9670;&#160;</a></span>validate_utf16le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf16le </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16LE string.This function may be best when you expect the input to be almost always valid. </p>
<p>Otherwise, consider using validate_utf16le_with_errors.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-16LE. </dd></dl>

</div>
</div>
<a id="a53ce751bb24df472a93e4c36e8a1b03d" name="a53ce751bb24df472a93e4c36e8a1b03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ce751bb24df472a93e4c36e8a1b03d">&#9670;&#160;</a></span>validate_utf16le_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf16le_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char16_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-16LE string and stop on error. </p>
<p>It might be faster than validate_utf16le when an error is expected to occur early.</p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-16LE string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 2-byte code units (char16_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="ab35c6765b2e4b97cc97ab9f3af52c9a9" name="ab35c6765b2e4b97cc97ab9f3af52c9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35c6765b2e4b97cc97ab9f3af52c9a9">&#9670;&#160;</a></span>validate_utf32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf32 </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-32 string. </p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-32. </dd></dl>

</div>
</div>
<a id="a825ad7513447a16cd12f5425e2e88431" name="a825ad7513447a16cd12f5425e2e88431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825ad7513447a16cd12f5425e2e88431">&#9670;&#160;</a></span>validate_utf32_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf32_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char32_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-32 string and stop on error. </p>
<p>Overridden by each implementation.</p>
<p>This function is not BOM-aware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-32 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in number of 4-byte code units (char32_t). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<a id="aaae969eb20db2099f92a504eb7db0bcf" name="aaae969eb20db2099f92a504eb7db0bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae969eb20db2099f92a504eb7db0bcf">&#9670;&#160;</a></span>validate_utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused bool simdutf::implementation::validate_utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-8 string. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the string is valid UTF-8. </dd></dl>

</div>
</div>
<a id="a42f53d3a9e9112a7ad4dfe67cfeccf07" name="a42f53d3a9e9112a7ad4dfe67cfeccf07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f53d3a9e9112a7ad4dfe67cfeccf07">&#9670;&#160;</a></span>validate_utf8_with_errors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual simdutf_warn_unused <a class="el" href="structsimdutf_1_1result.html">result</a> simdutf::implementation::validate_utf8_with_errors </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate the UTF-8 string and stop on errors. </p>
<p>Overridden by each implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>the UTF-8 string to validate. </td></tr>
    <tr><td class="paramname">len</td><td>the length of the string in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a result pair struct (of type <a class="el" href="structsimdutf_1_1result.html">simdutf::result</a> containing the two fields error and count) with an error code and either position of the error (in the input in code units) if any, or the number of code units validated if successful. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/simdutf/<a class="el" href="implementation_8h_source.html">implementation.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>simdutf</b></li><li class="navelem"><a class="el" href="classsimdutf_1_1implementation.html">implementation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
